{"version":3,"sources":["stopwatch.js"],"names":["factory","z","StopwatchWrapper","taskDescription","sw","Stopwatch","taskDesc","this","stop","duration","log","debug","start","_startTime","_stopTime","_running","Date","getTime","reset","classes","StopwatchStack","_stopwatchStack","_push","push","_pop","length","pop","swObj","defineProperty","get","writeable","root","window","global","define","amd","module","exports"],"mappings":"CAME,WACE,YACA,SAASA,GAAQC,GA+Db,QAASC,GAAiBC,GACtB,GAAIC,GAAK,GAAIC,GACTC,EAAWH,GAAmB,EAElCI,MAAKC,KAAO,WACR,GAAIC,GAAWL,EAAGI,MAElB,OADAP,GAAES,IAAIC,MAAML,EAAW,UAAYG,EAAW,OACvCA,GAGXL,EAAGQ,QAQP,QAASP,KACL,GAAIQ,GAAa,KACbC,EAAY,KACZC,GAAW,CAOfR,MAAKK,MAAQ,WACJG,IACDD,EAAY,KACZC,GAAW,EACXF,GAAa,GAAIG,OAAOC,YAShCV,KAAKC,KAAO,WAKR,MAJGO,KACCD,GAAY,GAAIE,OAAOC,UACvBF,GAAW,GAERR,KAAKE,YAQhBF,KAAKE,SAAW,WACZ,MAAKM,IAGO,GAAIC,OAAOC,UAAYJ,EAFvBC,EAAYD,GAU5BN,KAAKW,MAAQ,WACTH,GAAW,EACXF,EAAa,KACbC,EAAY,MAlIpBb,EAAEkB,QAAUlB,EAAEkB,WAOd,IAAIC,GAAiB,WAKjB,QAASA,KAEL,GAAIC,MASAC,EAAQ,SAASnB,GACjBkB,EAAgBE,KAAK,GAAIrB,GAAiBC,KAU1CqB,EAAO,WACP,MAAIH,GAAgBI,OAAS,EAClBJ,EAAgBK,MAAMlB,OADjC,OAIJ,OAAO,UAAUmB,GAGb,MAFA1B,GAAE2B,eAAeD,EAAO,QAAUE,IAAK,WAAa,MAAOP,IAAUQ,WAAW,IAChF7B,EAAE2B,eAAeD,EAAO,OAASE,IAAK,WAAa,MAAOL,IAASM,WAAW,IACvEH,OAIf,MAAOP,KAwFXnB,GAAEkB,QAAQC,eAAiBA,EAC3BnB,EAAEkB,QAAQjB,iBAAmBA,EAC7BD,EAAEkB,QAAQd,UAAYA,EACtBJ,EAAEG,GAAK,GAAIH,GAAEkB,QAAQC,eAMzB,GAAIW,GACkB,mBAAXC,QACHA,OACqB,mBAAXC,QACNA,OACE1B,IAEQ,oBAAX2B,SAAgD,mBAAfA,QAAOC,KAE/CD,OAAO,WAAa,MAAOlC,KAC3B+B,EAAK9B,EAAIA,GAEc,mBAAXmC,QACkB,mBAAnBA,QAAOC,UACdD,OAAOC,QAAUrC,GAGE,mBAAX+B,GAAK9B,GAEjBD,EAAQ+B,EAAK9B","file":"stopwatch.min.js","sourcesContent":["/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        /**\r\n            A class wrapper to contain a stack of stopwatches.\r\n            \r\n            @class Represents a stack of currently executing tasks.\r\n        */\r\n        var StopwatchStack = (function() {\r\n\r\n            /**\r\n                @constructor Initializes a new instance of the StopwatchStack class.\r\n            */\r\n            function StopwatchStack() {\r\n\r\n                var _stopwatchStack = [];\r\n\r\n                /**\r\n                    Creates and pushes a new StopwatchWrapper onto the task\r\n                    which contains the given taskDescription.\r\n                \r\n                    @param {string} taskDescription The description for the task to be timed.\r\n                    @returns {void}\r\n                */ \r\n                var _push = function(taskDescription) {\r\n                    _stopwatchStack.push(new StopwatchWrapper(taskDescription));\r\n                };\r\n\r\n                /**\r\n                    Pops the topmost executing StopwatchWrapper from the stack,\r\n                    which in turn will log the execution time using util.log.\r\n                 \r\n                    @param {string} taskDescription The description for the task to be timed.\r\n                    @returns {void}\r\n                */\r\n                var _pop = function() {\r\n                    if (_stopwatchStack.length > 0)\r\n                        return _stopwatchStack.pop().stop();\r\n                };\r\n\r\n                return (function(swObj) {\r\n                    z.defineProperty(swObj, \"push\", { get: function() { return _push; }, writeable: false });\r\n                    z.defineProperty(swObj, \"pop\", { get: function() { return _pop; }, writeable: false });\r\n                    return swObj;\r\n                })({});\r\n            }\r\n\r\n            return StopwatchStack;\r\n\r\n        })();\r\n\r\n        /**\r\n            Creates a new StopwatchWrapper, designed to wrap\r\n            the existing StopWatch class with a task description\r\n            and a logging functionality.\r\n\r\n            Used to keep the Stopwatch class clean,\r\n            so it may be implemented without\r\n            automated logging if necessary.\r\n\r\n            @class Represents a currently executing task.\r\n        */\r\n        function StopwatchWrapper(taskDescription) {\r\n            var sw = new Stopwatch();\r\n            var taskDesc = taskDescription || \"\";\r\n\r\n            this.stop = function() {\r\n                var duration = sw.stop();\r\n                z.log.debug(taskDesc + \" took: \" + duration + \" ms\");\r\n                return duration;\r\n            };\r\n            \r\n            sw.start();\r\n        }\r\n\r\n        /**\r\n            Creates a new Stopwatch.\r\n            \r\n            @class Represents a timer.\r\n        */\r\n        function Stopwatch() {\r\n            var _startTime = null;\r\n            var _stopTime = null;\r\n            var _running = false;\r\n\r\n            /**\r\n                Starts the stopwatch.\r\n                \r\n                @returns {void}\r\n            */\r\n            this.start = function() {\r\n                if (!_running) {\r\n                    _stopTime = null;\r\n                    _running = true;\r\n                    _startTime = new Date().getTime();\r\n                }\r\n            };\r\n\r\n            /**\r\n                Stops the stopwatch.\r\n                \r\n                @returns {void}\r\n            */\r\n            this.stop = function() {\r\n                if(_running) {\r\n                    _stopTime = new Date().getTime();\r\n                    _running = false;\r\n                }\r\n                return this.duration();\r\n            };\r\n\r\n            /**\r\n                Collects the execution duration for the stopwatch.\r\n                \r\n                @returns {number} The duration of the timer in milliseconds.\r\n            */\r\n            this.duration = function() {\r\n                if (!_running)\r\n                    return (_stopTime - _startTime);\r\n                else\r\n                    return (new Date().getTime() - _startTime);\r\n            };\r\n\r\n            /**\r\n                Resets the stopwatch to the initialized state. the execution duration for the stopwatch.\r\n                \r\n                @returns {void}\r\n            */\r\n            this.reset = function() {\r\n                _running = false;\r\n                _startTime = null;\r\n                _stopTime = null;\r\n            };\r\n        }\r\n\r\n        z.classes.StopwatchStack = StopwatchStack;\r\n        z.classes.StopwatchWrapper = StopwatchWrapper;\r\n        z.classes.Stopwatch = Stopwatch;\r\n        z.sw = new z.classes.StopwatchStack();\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}()); "],"sourceRoot":"/source/"}