{"version":3,"sources":["numbers.js"],"names":["factory","z","numbers","factors","argsIterator","source","getType","this","types","number","arguments","assert","isNumber","small","large","i","Math","floor","sqrt","push","concat","reverse","round","roundBy","direction","toString","toLowerCase","roundDown","roundUp","ceil","extendTo","obj","defineProperty","enumerable","writable","value","setup","initNumbers","usePrototype","Number","prototype","root","window","global","define","amd","module","exports"],"mappings":"CAME,WACE,YACA,SAASA,GAAQC,GAEb,GAAIC,GAAUD,EAAEC,UAQhBA,GAAQC,QAAU,WACd,GAAIC,GAAe,EACfC,EAASJ,EAAEK,QAAQC,QAAUN,EAAEO,MAAMC,OAASF,KAAOG,UAAUN,IACnEH,GAAEU,OAAOC,SAASP,EAGlB,KAAK,GAFDQ,MACAC,KACKC,EAAI,EAAGA,GAAKC,KAAKC,MAAMD,KAAKE,KAAKb,IAAUU,IAC5CV,EAASU,IAAM,IACfF,EAAMM,KAAKJ,GACPV,EAASU,IAAMA,GACfD,EAAMK,KAAKd,EAASU,GAIhC,OAAOF,GAAMO,OAAON,EAAMO,YAU9BnB,EAAQoB,MAAQ,WACZ,GAAIlB,GAAe,EACfC,EAASJ,EAAEK,QAAQC,QAAUN,EAAEO,MAAMC,OAASF,KAAOG,UAAUN,KAC/DmB,EAAUb,UAAUN,MAAmB,EACvCoB,EAAYd,UAAUN,IAE1B,IADAH,EAAEU,OAAOC,SAASP,GACdmB,EAAW,CAEX,GADAA,EAAYA,EAAUC,WAAWC,cACf,SAAdF,EACA,MAAOvB,GAAEC,QAAQyB,UAAUtB,EAAQkB,EAElC,IAAkB,OAAdC,EACL,MAAOvB,GAAEC,QAAQ0B,QAAQvB,EAAQkB,GAGzC,MAAOP,MAAKM,MAAMjB,EAASkB,GAAWA,GAU1CrB,EAAQyB,UAAY,WAChB,GAAIvB,GAAe,EACfC,EAASJ,EAAEK,QAAQC,QAAUN,EAAEO,MAAMC,OAASF,KAAOG,UAAUN,KAC/DmB,EAAUb,UAAUN,MAAmB,CAE3C,OADAH,GAAEU,OAAOC,SAASP,GACXW,KAAKC,MAAMZ,EAASkB,GAAWA,GAU1CrB,EAAQ0B,QAAU,WACd,GAAIxB,GAAe,EACfC,EAASJ,EAAEK,QAAQC,QAAUN,EAAEO,MAAMC,OAASF,KAAOG,UAAUN,KAC/DmB,EAAUb,UAAUN,MAAmB,CAE3C,OADAH,GAAEU,OAAOC,SAASP,GACXW,KAAKa,KAAKxB,EAASkB,GAAWA,GAQzCrB,EAAQ4B,SAAW,SAASC,GACxB9B,EAAE+B,eAAeD,EAAK,WAAaE,YAAY,EAAOC,UAAU,EAAMC,MAAOlC,EAAEC,QAAQC,UACvFF,EAAE+B,eAAeD,EAAK,SAAWE,YAAY,EAAOC,UAAU,EAAMC,MAAOlC,EAAEC,QAAQoB,QACrFrB,EAAE+B,eAAeD,EAAK,aAAeE,YAAY,EAAOC,UAAU,EAAMC,MAAOlC,EAAEC,QAAQyB,YACzF1B,EAAE+B,eAAeD,EAAK,WAAaE,YAAY,EAAOC,UAAU,EAAMC,MAAOlC,EAAEC,QAAQ0B,WAU3F3B,EAAEmC,MAAMC,YAAc,SAASC,GACrBA,GACFpC,EAAQ4B,SAASS,OAAOC,YAOpC,GAAIC,GACkB,mBAAXC,QACHA,OACqB,mBAAXC,QACNA,OACEpC,IAEQ,oBAAXqC,SAAgD,mBAAfA,QAAOC,KAE/CD,OAAO,WAAa,MAAO5C,KAC3ByC,EAAKxC,EAAIA,GAEc,mBAAX6C,QACkB,mBAAnBA,QAAOC,UACdD,OAAOC,QAAU/C,GAGE,mBAAXyC,GAAKxC,GAEjBD,EAAQyC,EAAKxC","file":"numbers.min.js","sourcesContent":["/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        var numbers = z.numbers = {};\r\n\r\n        /**\r\n            Calculates and returns the factors for the provided integer.\r\n            \r\n            @param {integer} source The original integer.\r\n            @returns An array containing the divisors for the integer.\r\n        */\r\n        numbers.factors = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            z.assert.isNumber(source);\r\n            var small = [];\r\n            var large = [];\r\n            for (var i = 1; i <= Math.floor(Math.sqrt(source)); i++) {\r\n                if (source % i === 0) {\r\n                    small.push(i);\r\n                    if (source / i !== i) {\r\n                        large.push(source / i);\r\n                    }\r\n                }\r\n            }\r\n            return small.concat(large.reverse()); // note: push and reverse is anywhere from 2x-54x faster than using unshift\r\n        };\r\n\r\n        /**\r\n            Rounds the provided number to the nearest provided step.\r\n            \r\n            @param {number} source The original number.\r\n            @param {number} roundBy The step to round by.\r\n            @returns {number}\r\n        */\r\n        numbers.round = function(/* source, roundBy, direction */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            var roundBy = arguments[argsIterator++] || 1;\r\n            var direction = arguments[argsIterator++];\r\n            z.assert.isNumber(source);\r\n            if (direction) {\r\n                direction = direction.toString().toLowerCase();\r\n                if (direction === 'down') {\r\n                    return z.numbers.roundDown(source, roundBy);\r\n                }\r\n                else if (direction === 'up') {\r\n                    return z.numbers.roundUp(source, roundBy);\r\n                }\r\n            }\r\n            return Math.round(source / roundBy) * roundBy;\r\n        };\r\n\r\n        /**\r\n            Rounds the provided number down to the nearest provided step.\r\n            \r\n            @param {number} source The original number.\r\n            @param {number} roundBy The step to round by.\r\n            @returns {number} \r\n        */\r\n        numbers.roundDown = function(/* source, roundBy */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            var roundBy = arguments[argsIterator++] || 1;\r\n            z.assert.isNumber(source);\r\n            return Math.floor(source / roundBy) * roundBy;\r\n        };\r\n\r\n        /**\r\n            Rounds the provided number up to the nearest provided step.\r\n            \r\n            @param {number} source The original number.\r\n            @param {number} roundBy The step to round by.\r\n            @returns {number} \r\n        */\r\n        numbers.roundUp = function(/* source, roundBy */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            var roundBy = arguments[argsIterator++] || 1;\r\n            z.assert.isNumber(source);\r\n            return Math.ceil(source / roundBy) * roundBy;\r\n        };\r\n\r\n        /**\r\n            Places all number extensions on the provided object or prototype.\r\n\r\n            @param {obj} object The object to be extended with number methods.\r\n        */\r\n        numbers.extendTo = function(obj) {\r\n            z.defineProperty(obj, \"factors\", { enumerable: false, writable: true, value: z.numbers.factors });\r\n            z.defineProperty(obj, \"round\", { enumerable: false, writable: true, value: z.numbers.round });\r\n            z.defineProperty(obj, \"roundDown\", { enumerable: false, writable: true, value: z.numbers.roundDown });\r\n            z.defineProperty(obj, \"roundUp\", { enumerable: false, writable: true, value: z.numbers.roundUp });\r\n        };\r\n\r\n        /**\r\n            Initializes all pre-defined methods\r\n            as non-enumerable and non-writable properties\r\n            located on the Number.prototype.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initNumbers = function(usePrototype) {\r\n            if (!!usePrototype)\r\n                numbers.extendTo(Number.prototype);\r\n        };\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());"],"sourceRoot":"/source/"}