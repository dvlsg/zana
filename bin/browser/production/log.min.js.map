{"version":3,"sources":["log.js"],"names":["undefined","factory","z","classes","data","expectedMethods","verifyLoggerInterface","logger","assert","exists","i","length","method","isFunction","bindLoggers","loggerToBind","newLogInterface","log","bind","debug","check","error","info","warn","LogInterface","enableDebugLogging","_internalLogInterface","setDebugLogging","useDebugLogging","getType","types","string","str","toLowerCase","trim","setLogger","newLogger","location","parameters","newLog","defineProperty","get","functions","empty","writeable","setup","initLogger","defaultLogger","root","window","global","this","define","amd","module","exports"],"mappings":"CAME,SAASA,GACP,YACA,SAASC,GAAQC,GAEbA,EAAEC,QAAUD,EAAEC,WAEd,IAAIC,IACAC,iBACI,QAgBJC,EAAwB,SAASC,GACjCL,EAAEM,OAAOC,OAAOF,EAChB,KAAK,GAAIG,GAAI,EAAGA,EAAIN,EAAKC,gBAAgBM,OAAQD,IAAK,CAClD,GAAIE,GAASR,EAAKC,gBAAgBK,EAClCR,GAAEM,OAAOK,WAAWN,EAAOK,MAY/BE,EAAc,SAASC,EAAcC,GACrCV,EAAsBS,GACtBC,EAAgBC,IAAMF,EAAaE,IAAIC,KAAKH,GAG5CC,EAAgBG,MAAQjB,EAAEkB,MAAMX,OAAOM,EAAaI,OAASJ,EAAaI,MAAMD,KAAKH,GAAgBA,EAAaE,IAAIC,KAAKH,GAC3HC,EAAgBK,MAAQnB,EAAEkB,MAAMX,OAAOM,EAAaM,OAASN,EAAaM,MAAMH,KAAKH,GAAgBA,EAAaE,IAAIC,KAAKH,GAC3HC,EAAgBM,KAAOpB,EAAEkB,MAAMX,OAAOM,EAAaO,MAAQP,EAAaO,KAAKJ,KAAKH,GAAgBA,EAAaE,IAAIC,KAAKH,GACxHC,EAAgBO,KAAOrB,EAAEkB,MAAMX,OAAOM,EAAaQ,MAAQR,EAAaQ,KAAKL,KAAKH,GAAgBA,EAAaE,IAAIC,KAAKH,IAUxHS,EAAe,WASf,QAASA,GAAajB,EAAQkB,GAE1B,GAAIC,MAQAC,EAAkB,SAASC,GACvB1B,EAAE2B,QAAQD,KAAqB1B,EAAE4B,MAAMC,SACvCH,EAAkB,SAAUI,GACxB,OAAQA,EAAIC,cAAcC,QACtB,IAAK,QACL,IAAK,IACL,IAAK,GACL,IAAK,MACL,IAAKlC,GACD,OAAO,CACX,SACI,OAAO,IAEhB4B,IAEPF,EAAsBE,kBAAoBA,GAa1CO,EAAY,SAASC,GACrBtB,EAAYsB,EAAWV,GACvBC,EAAsC,MAAtBF,EAA6BA,EAAsBvB,EAAEmC,SAAWnC,EAAEmC,SAASC,WAAWnB,OAAQ,GAWlH,OATAgB,GAAU5B,GASH,SAAUgC,GAqCb,MAjBArC,GAAEsC,eAAeD,EAAQ,SACrBE,IAAK,WACD,MAAIf,GAAsBE,gBACfF,EAAsBP,MAGtBjB,EAAEwC,UAAUC,OAG3BC,WAAW,IAEf1C,EAAEsC,eAAeD,EAAQ,SAAWE,IAAK,WAAa,MAAOf,GAAsBL,OAAUuB,WAAW,IACxG1C,EAAEsC,eAAeD,EAAQ,QAAUE,IAAK,WAAa,MAAOf,GAAsBJ,MAASsB,WAAW,IACtG1C,EAAEsC,eAAeD,EAAQ,OAASE,IAAK,WAAa,MAAOf,GAAsBT,KAAQ2B,WAAW,IACpG1C,EAAEsC,eAAeD,EAAQ,QAAUE,IAAK,WAAa,MAAOf,GAAsBH,MAASqB,WAAW,IACtG1C,EAAEsC,eAAeD,EAAQ,mBAAqBE,IAAK,WAAa,MAAOd,IAAoBiB,WAAW,IACtG1C,EAAEsC,eAAeD,EAAQ,aAAeE,IAAK,WAAa,MAAON,IAAcS,WAAW,IACnFL,GACRb,EAAsBT,KAG7B,MAAOO,KASXtB,GAAE2C,MAAMC,WAAa,SAASC,GACtB7C,EAAEkB,MAAMX,OAAOsC,KACf7C,EAAEe,IAAM,GAAIf,GAAEC,QAAQqB,aAAauB,KAI3C7C,EAAEC,QAAQqB,aAAeA,EAM7B,GAAIwB,GACkB,mBAAXC,QACHA,OACqB,mBAAXC,QACNA,OACEC,IAEQ,oBAAXC,SAAgD,mBAAfA,QAAOC,KAE/CD,OAAO,WAAa,MAAOnD,KAC3B+C,EAAK9C,EAAIA,GAEc,mBAAXoD,QACkB,mBAAnBA,QAAOC,UACdD,OAAOC,QAAUtD,GAGE,mBAAX+C,GAAK9C,GAEjBD,EAAQ+C,EAAK9C","file":"log.min.js","sourcesContent":["/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        var data = {\r\n            expectedMethods: [\r\n                \"log\"\r\n                // \"debug\"\r\n                // , \"error\"\r\n                // , \"info\"\r\n                // , \"log\"\r\n                // , \"warn\"\r\n            ]\r\n        };\r\n\r\n        /**\r\n            An internal helper function used to determine\r\n            whether or not the provided logger object\r\n            is a proper interface for the Log class.\r\n        \r\n            @param {object} logger The log interface to check for expected methods\r\n        */\r\n        var verifyLoggerInterface = function(logger) {\r\n            z.assert.exists(logger);\r\n            for (var i = 0; i < data.expectedMethods.length; i++) {\r\n                var method = data.expectedMethods[i];\r\n                z.assert.isFunction(logger[method]);\r\n            }\r\n        };\r\n\r\n        /**\r\n            Helper method used to binds the LogInterfaces's internal interface\r\n            to the provided external logger interface methods.\r\n\r\n            @param {object} loggerToBind The interface containing the expected log methods.\r\n            @param {object} newLogInterface The object reference to the LogInterface's internal interface.\r\n            @returns {void}\r\n        */\r\n        var bindLoggers = function(loggerToBind, newLogInterface) {\r\n            verifyLoggerInterface(loggerToBind);\r\n            newLogInterface.log = loggerToBind.log.bind(loggerToBind);\r\n\r\n            // fall back to using the \"log\" method \r\n            newLogInterface.debug = z.check.exists(loggerToBind.debug) ? loggerToBind.debug.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n            newLogInterface.error = z.check.exists(loggerToBind.error) ? loggerToBind.error.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n            newLogInterface.info = z.check.exists(loggerToBind.info) ? loggerToBind.info.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n            newLogInterface.warn = z.check.exists(loggerToBind.warn) ? loggerToBind.warn.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n        };\r\n\r\n        /**\r\n            A wrapper class used to hold and execute different logging interfaces.\r\n            Note that the provided log interface is expected to contain at least\r\n            a debug, error, info, log, and warn method.\r\n\r\n            @class Contains a provided logging interface.\r\n         */\r\n        var LogInterface = (function() {\r\n\r\n            /**\r\n                Creates a new Log class.\r\n\r\n                @constructor\r\n                @param {object} logger The interface containing the expected log methods.\r\n                @param {bool} [enableDebugLogging] An override for enabling debug logging on Log class creation.\r\n            */\r\n            function LogInterface(logger, enableDebugLogging) {\r\n\r\n                var _internalLogInterface = {};\r\n\r\n                /**\r\n                    Sets the use debug logging flag to the provided boolean.\r\n\r\n                    @param {boolean} useDebugLogging The boolean used to set the debug logging flag.\r\n                    @returns {void}\r\n                */\r\n                var setDebugLogging = function(useDebugLogging) {\r\n                    if (z.getType(useDebugLogging) === z.types.string) {\r\n                        useDebugLogging = (function(str) {\r\n                            switch (str.toLowerCase().trim()) {\r\n                                case \"false\":\r\n                                case \"0\":\r\n                                case \"\":\r\n                                case null:\r\n                                case undefined:\r\n                                    return false;\r\n                                default:\r\n                                    return true;\r\n                            }\r\n                        })(useDebugLogging);\r\n                    }\r\n                    _internalLogInterface.useDebugLogging = !!useDebugLogging;\r\n                };\r\n\r\n                /**\r\n                    Sets the already created log object\r\n                    to the newly provided logger interface.\r\n\r\n                    Note that method is also immediately executed\r\n                    to initialize the provided logger interface.\r\n                    \r\n                    @param {object} newLogger The new logger interface.\r\n                    @returns {void}\r\n                */\r\n                var setLogger = function(newLogger) {\r\n                    bindLoggers(newLogger, _internalLogInterface);\r\n                    setDebugLogging(enableDebugLogging != null ? enableDebugLogging : (z.location ? z.location.parameters.debug : false));\r\n                };\r\n                setLogger(logger);\r\n\r\n                /**\r\n                    Extends a function into a log interface with\r\n                    the pre-determined, privately stored properties,\r\n                    returning it back to the original Log() call.\r\n\r\n                    @returns {function} The extended function.\r\n                */\r\n                return (function(newLog) {\r\n                    /**\r\n                        The base LogInterface function to be returned.\r\n                        Note that the base function can be called\r\n                        as a pass-through method for the _log without\r\n                        needing to directly call LogInterface.log()\r\n\r\n                        Note: Using this method seems a LOT safer,\r\n                        and prevents _log from containing a self-reference.\r\n                        The downside is that the console call will be recorded \r\n                        as coming from this location in log.js,\r\n                        instead of the util.log() line in client code.\r\n\r\n                        @param {any} [x] The item to pass to the LogInterface.log() function.\r\n                        @returns {any} The extended item.\r\n                    */\r\n                    // var newLog = function(x) {\r\n                    //     _log(x); // default a LogInterface(x) call to use _log(x)\r\n                    // };\r\n\r\n                    z.defineProperty(newLog, \"debug\", {\r\n                        get: function() { \r\n                            if (_internalLogInterface.useDebugLogging) {\r\n                                return _internalLogInterface.debug;\r\n                            }\r\n                            else {\r\n                                return z.functions.empty;\r\n                            }\r\n                        },\r\n                        writeable: false\r\n                    });\r\n                    z.defineProperty(newLog, \"error\", { get: function() { return _internalLogInterface.error; }, writeable: false });\r\n                    z.defineProperty(newLog, \"info\", { get: function() { return _internalLogInterface.info; }, writeable: false });\r\n                    z.defineProperty(newLog, \"log\", { get: function() { return _internalLogInterface.log; }, writeable: false });\r\n                    z.defineProperty(newLog, \"warn\", { get: function() { return _internalLogInterface.warn; }, writeable: false });\r\n                    z.defineProperty(newLog, \"setDebugLogging\", { get: function() { return setDebugLogging; }, writeable: false });\r\n                    z.defineProperty(newLog, \"setLogger\", { get: function() { return setLogger; }, writeable: false });\r\n                    return newLog;\r\n                })(_internalLogInterface.log); // note these shenanigans -- seems dangerous, and _log will contain a self-reference\r\n            }\r\n\r\n            return LogInterface;\r\n            \r\n        })();\r\n\r\n        /**\r\n            Initializes a logger interface provided by the setup object.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initLogger = function(defaultLogger) {\r\n            if (z.check.exists(defaultLogger)) {\r\n                z.log = new z.classes.LogInterface(defaultLogger);\r\n            }\r\n        };\r\n\r\n        z.classes.LogInterface = LogInterface;\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());"],"sourceRoot":"/source/"}