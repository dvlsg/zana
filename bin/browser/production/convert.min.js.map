{"version":3,"sources":["convert.js"],"names":["undefined","factory","z","classes","convert","source","toType","assert","isString","types","toBoolean","date","toDate","number","toNumber","check","exists","isFunction","getType","string","toLowerCase","trim","Date","parse","toString","Converter","newConverter","defineProperty","get","writeable","root","window","global","this","define","amd","module","exports"],"mappings":"CAME,SAASA,GACP,YACA,SAASC,GAAQC,GAEbA,EAAEC,QAAUD,EAAEC,WAUd,IAAIC,GAAU,SAASC,EAAQC,GAE3B,OADAJ,EAAEK,OAAOC,SAASF,GACVA,GACJ,IAAKJ,GAAEO,MAAFP,WAAiB,MAAOQ,GAAUL,EACvC,KAAKH,GAAEO,MAAME,KAAM,MAAOC,GAAOP,EACjC,KAAKH,GAAEO,MAAMI,OAAQ,MAAOC,GAAST,KAUzCK,EAAY,SAASL,GACrB,GAAIH,EAAEa,MAAMC,OAAOX,IAAWH,EAAEa,MAAME,WAAWZ,EAAOK,WACpD,MAAOL,GAAOK,WAElB,QAAQR,EAAEgB,QAAQb,IACd,IAAKH,GAAEO,MAAFP,WACD,MAAOG,EACX,KAAKH,GAAEO,MAAMU,OACT,OAAQd,EAAOe,cAAcC,QACzB,IAAK,QACL,IAAK,IACL,IAAK,GACL,IAAK,MACL,IAAKrB,GACD,OAAO,CACX,SACI,OAAO,EAEf,KACJ,SACI,QAASK,IAUjBO,EAAS,SAASP,GAClB,GAAIH,EAAEa,MAAMC,OAAOX,IAAWH,EAAEa,MAAME,WAAWZ,EAAOO,QACpD,MAAOP,GAAOO,QAElB,QAAQV,EAAEgB,QAAQb,IACd,IAAKH,GAAEO,MAAME,KACT,MAAON,EACX,KAAKH,GAAEO,MAAMU,OACT,MAAO,IAAIG,MAAKA,KAAKC,MAAMlB,GAC/B,SACI,MAAO,IAAIiB,MAAKA,KAAKC,MAAMlB,EAAOmB,eAU1CV,EAAW,SAAST,GACpB,GAAIH,EAAEa,MAAMC,OAAOX,IAAWH,EAAEa,MAAME,WAAWZ,EAAOS,UACpD,MAAOT,GAAOS,UAElB,QAAQZ,EAAEgB,QAAQb,IACd,IAAKH,GAAEO,MAAMI,OACT,MAAOR,EACX,SACI,OAAQA,IAShBoB,EAAY,WASZ,QAASA,KASL,MAAO,UAAUC,GAab,MAHAxB,GAAEyB,eAAeD,EAAc,aAAeE,IAAK,WAAa,MAAOlB,IAAcmB,WAAW,IAChG3B,EAAEyB,eAAeD,EAAc,UAAYE,IAAK,WAAa,MAAOhB,IAAWiB,WAAW,IAC1F3B,EAAEyB,eAAeD,EAAc,YAAcE,IAAK,WAAa,MAAOd,IAAae,WAAW,IACvFH,GACRtB,GAGP,MAAOqB,KAIXvB,GAAEC,QAAQsB,UAAYA,EACtBvB,EAAEE,QAAU,GAAIF,GAAEC,QAAQsB,UAM9B,GAAIK,GACkB,mBAAXC,QACHA,OACqB,mBAAXC,QACNA,OACEC,IAEQ,oBAAXC,SAAgD,mBAAfA,QAAOC,KAE/CD,OAAO,WAAa,MAAOjC,KAC3B6B,EAAK5B,EAAIA,GAEc,mBAAXkC,QACkB,mBAAnBA,QAAOC,UACdD,OAAOC,QAAUpC,GAGE,mBAAX6B,GAAK5B,GAEjBD,EAAQ6B,EAAK5B","file":"convert.min.js","sourcesContent":["/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        /**\r\n            Executes a conversion for a given source and type.\r\n            \r\n            @param {any} source The item to convert.\r\n            @param {string} toType The type to which to convert.\r\n            @returns {any} The converted source.\r\n            @throws {error} An error is thrown if toType is not a string.\r\n        */\r\n        var convert = function(source, toType) {\r\n            z.assert.isString(toType);\r\n            switch (toType) {\r\n                case z.types.boolean: return toBoolean(source);\r\n                case z.types.date: return toDate(source);\r\n                case z.types.number: return toNumber(source);\r\n            }\r\n        };\r\n\r\n        /**\r\n            Executes a conversion to boolean for a given source.\r\n            \r\n            @param {any} source The item to convert.\r\n            @returns {boolean} The converted source.\r\n        */\r\n        var toBoolean = function(source) {\r\n            if (z.check.exists(source) && z.check.isFunction(source.toBoolean)) {\r\n                return source.toBoolean(); // allow override to be supplied directly on the source object\r\n            }\r\n            switch (z.getType(source)) {\r\n                case z.types.boolean:\r\n                    return source;\r\n                case z.types.string:\r\n                    switch (source.toLowerCase().trim()) {\r\n                        case \"false\":\r\n                        case \"0\":\r\n                        case \"\":\r\n                        case null:\r\n                        case undefined:\r\n                            return false;\r\n                        default:\r\n                            return true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return !!source;\r\n            }\r\n        };\r\n\r\n        /**\r\n            Executes a conversion to a date for a given source.\r\n            \r\n            @param {any} source The item to convert.\r\n            @returns {date} The converted source.\r\n        */\r\n        var toDate = function(source) {\r\n            if (z.check.exists(source) && z.check.isFunction(source.toDate)) {\r\n                return source.toDate();\r\n            }\r\n            switch (z.getType(source)) {\r\n                case z.types.date:\r\n                    return source;\r\n                case z.types.string:\r\n                    return new Date(Date.parse(source));\r\n                default:\r\n                    return new Date(Date.parse(source.toString()));\r\n            }\r\n        };\r\n\r\n        /**\r\n            Executes a conversion to a number for a given source.\r\n            \r\n            @param {any} source The item to convert.\r\n            @returns {boolean} The converted source.\r\n        */\r\n        var toNumber = function(source) {\r\n            if (z.check.exists(source) && z.check.isFunction(source.toNumber)) {\r\n                return source.toNumber(); // allow override to be supplied directly on the source object\r\n            }\r\n            switch (z.getType(source)) {\r\n                case z.types.number:\r\n                    return source;\r\n                default:\r\n                    return +source;\r\n            }\r\n        };\r\n\r\n        /**\r\n            A wrapper class used to hold and execute different assertion methods.\r\n\r\n            @class Contains a provided set of assertions.\r\n         */\r\n        var Converter = (function() {\r\n\r\n            /**\r\n                Creates a new Asserter class.\r\n\r\n                @constructor\r\n                @param {object} logger The interface containing the expected log methods.\r\n                @param {bool} [enableDebugLogging] An override for enabling debug logging on Log class creation.\r\n            */\r\n            function Converter() {\r\n\r\n                /**\r\n                    Extends a function into an Asserter interface with\r\n                    the pre-determined, privately stored properties,\r\n                    returning it back to the original Asserter() call.\r\n\r\n                    @returns {function} The extended function.\r\n                */\r\n                return (function(newConverter) {\r\n                    /**\r\n                        The base Asserter function to be returned.\r\n                        Note that the base function can be called\r\n                        as a pass-through method for _assert without\r\n                        needing to directly call LogInterface.log()\r\n\r\n                        @param {any} [x] The item to extend and return to the Asserter class.\r\n                        @returns {any} The extended item.\r\n                    */\r\n                    z.defineProperty(newConverter, \"toBoolean\", { get: function() { return toBoolean; }, writeable: false });\r\n                    z.defineProperty(newConverter, \"toDate\", { get: function() { return toDate; }, writeable: false });\r\n                    z.defineProperty(newConverter, \"toNumber\", { get: function() { return toNumber; }, writeable: false });\r\n                    return newConverter;\r\n                })(convert);\r\n            }\r\n\r\n            return Converter;\r\n            \r\n        })();\r\n\r\n        z.classes.Converter = Converter;\r\n        z.convert = new z.classes.Converter();\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());"],"sourceRoot":"/source/"}