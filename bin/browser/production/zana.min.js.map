{"version":3,"sources":["base.js","arrays.js","assert.js","check.js","convert.js","events.js","functions.js","location.js","log.js","numbers.js","objects.js","stopwatch.js"],"names":[],"mappings":"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","file":"zana.min.js","sourcesContent":["/**\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    /**\r\n        The main container for all zUtil items.\r\n\r\n        @param [object] settings An optional set of settings to define items.\r\n        @param [boolean] settings.useArrayExtensions A boolean flag to determine whether or not to extend Array.prototype.\r\n        @param [boolean] settings.useObjectExtensions A boolean flag to determine whether or not to extend Object.prototype.\r\n        @param [object] settings.defaultLogger An object which defines all of the required logger fields to be used by zUtil.log.\r\n    */\r\n    function Zana(/* settings */) {\r\n        // this.setup(settings);\r\n    }\r\n    var z = new Zana();\r\n\r\n    /**\r\n        Class for containing a max reference counter\r\n        as well as two stacks of references to objects.\r\n        To be used with deepCopy and equals.\r\n        \r\n        @class Contains two reference stacks as well as a defined max stack depth.\r\n    */\r\n    var RecursiveCounter = (function() {\r\n        function RecursiveCounter(maxStackDepth) {\r\n            this.xStack = [];\r\n            this.yStack = [];\r\n            this.count = 0;\r\n            this.maxStackDepth = maxStackDepth;\r\n        }\r\n        RecursiveCounter.prototype.push = function(x, y) {\r\n            this.xStack.push(x);\r\n            this.yStack.push(y);\r\n            this.count++;\r\n        };\r\n        RecursiveCounter.prototype.pop = function() {\r\n            this.xStack.pop();\r\n            this.yStack.pop();\r\n            this.count--;\r\n        };\r\n        return RecursiveCounter;\r\n    })();\r\n\r\n    /**\r\n        Collects the type for a given value.\r\n        \r\n        @param {any} value The value from which to collect the type.\r\n        @returns {string} The type of the value.\r\n    */\r\n    z.getType = function(value) {\r\n        return Object.prototype.toString.call(value).match(/^\\[object (.+)\\]$/)[1];\r\n    };\r\n\r\n    /**\r\n        Returns the first non-null or non-undefined argument.\r\n\r\n        @param {...any} var_args The list of arguments to check for existence.\r\n        @returns {any} If no arguments exist then null, else the existing argument.\r\n    */\r\n    z.coalesce = function(/* arguments */) {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        for (var i = 0; i < args.length; i++) {\r\n            if (z.check.exists(args[i])) {\r\n                return args[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /**\r\n        Builds a deep copy of the provided source.\r\n        \r\n        @param {any} origSource The item from which to build the deep copy.\r\n        @returns {any} The copy of the provided source.\r\n        @throws {error} An error is thrown if the recursive object stack grows greater than 1000.\r\n    */\r\n    z.deepCopy = function(origSource) {\r\n        var origIndex = -1;\r\n        var rc = new RecursiveCounter(1000);\r\n\r\n        function _singleCopy(sourceRef, copyRef) {\r\n            origIndex = rc.xStack.indexOf(sourceRef);\r\n            if (origIndex === -1) {\r\n                rc.push(sourceRef, copyRef);\r\n                z.forEach(sourceRef, function(value, key) {\r\n                    copyRef[key] = _deepCopy(value);\r\n                });\r\n                rc.pop();\r\n                return copyRef;\r\n            }\r\n            else {\r\n                // source item has already been copied\r\n                // return the reference to the copied item\r\n                return rc.yStack[origIndex];\r\n            }\r\n        }\r\n\r\n        function _funcCopy(source) {\r\n            // rebuild the function from the original body and arguments\r\n            // var s = source.toString();\r\n            // var args = s.substring(s.indexOf(\"(\")+1, s.indexOf(\")\")).trim().split(\",\");\r\n            // args.map(function(val, index, arr) {\r\n            //     arr[index] = val.trim();\r\n            // });\r\n            // var body = s.substring(s.indexOf(\"{\")+1, s.indexOf(\"}\")).trim();\r\n            // var anonymous = new Function(args, body); // may need to consider the \"this\" property\r\n            // // make sure we collect any properties which may have been set on the function\r\n\r\n            var temp = function() { return source.apply(source, arguments); };\r\n            z.forEach(source, function(x, key) {\r\n                temp[key] = _deepCopy(x);\r\n            });\r\n\r\n            return _singleCopy(source, temp);\r\n\r\n            // return _singleCopy(source, anonymous);\r\n        }\r\n\r\n        function _deepCopy(source) {\r\n            if (rc.count > rc.maxStackDepth) throw new Error(\"Stack depth exceeded: \" + rc.stackMaxDepth + \"!\");\r\n            switch (z.getType(source)) {\r\n                case z.types.object:\r\n                    return _singleCopy(source, Object.create(Object.getPrototypeOf(source)));\r\n                case z.types.array:\r\n                    return _singleCopy(source, []);\r\n                case z.types.regexp:\r\n                    return _singleCopy(source, new RegExp(source));\r\n                case z.types.date:\r\n                    return _singleCopy(source, new Date(source.toString()));\r\n                case z.types.function:\r\n                    return _funcCopy(source);\r\n                default: // need to handle functions differently?\r\n                    return source;\r\n            }\r\n        }\r\n        return _deepCopy(origSource);\r\n    };\r\n\r\n    /**\r\n        Defines a property on this provided item.\r\n        \r\n        @this {object}\r\n        @param {any} obj The item to which to add the property.\r\n        @param {string} name The name of the property.\r\n        @param {any} prop The property to add.\r\n        @returns {void}\r\n    */\r\n    z.defineProperty = function(obj, name, prop) {\r\n        if (obj[name] == null) {\r\n            Object.defineProperty(obj, name, prop); \r\n        }\r\n        else {\r\n            console.error(\r\n                \"Error: the method \" \r\n                + name\r\n                + \" has already been defined on the following object: \" \r\n                + obj\r\n            );\r\n        }\r\n    };\r\n\r\n    /**\r\n        Compares the equality of two provided items.\r\n        \r\n        @param {any} x The first item to compare.\r\n        @param {any} y The second item to compare.\r\n        @returns {boolean} True if the provided values are equal, false if not.\r\n        @throws {error} An error is thrown if the recursive function stack grows greater than 1000.\r\n    */\r\n    z.equals = function(x, y) {\r\n        var rc = new RecursiveCounter(1000);\r\n\r\n        function _compareObject(x, y) {\r\n            // check for reference equality\r\n            if (x === y) {\r\n                return true;\r\n            }\r\n            var xKeys = Object.keys(x);\r\n            var yKeys = Object.keys(y);\r\n            xKeys.quicksort();\r\n            yKeys.quicksort();\r\n            if (!_equals(xKeys, yKeys)) {\r\n                return false;\r\n            }\r\n            rc.push(x, y);\r\n            for (var k in x) {\r\n                if (!_equals(x[k], y[k])) {\r\n                    return false;\r\n                }\r\n            }\r\n            rc.pop();\r\n            return true;\r\n        }\r\n\r\n        function _equals(x, y) {\r\n            if (rc.count > rc.maxStackDepth) throw new Error(\"Stack depth exceeded: \" + rc.maxStackDepth + \"!\");\r\n            // check for reference and primitive equality\r\n            if (x === y) {\r\n                return true;\r\n            }\r\n            // check for type equality\r\n            var xType = z.getType(x);\r\n            var yType = z.getType(y);\r\n            if (xType !== yType) {\r\n                return false;\r\n            }\r\n            // check for circular references\r\n            var xIndex = rc.xStack.lastIndexOf(x);\r\n            var yIndex = rc.yStack.lastIndexOf(y);\r\n            if (xIndex !== -1) {\r\n                if (yIndex !== -1) {\r\n                    // don't care about object reference equality\r\n                    // when checking for object equality\r\n                    return true;\r\n                    // if we do care about object reference equality,\r\n                    // then a strict comparison of stack location of objects\r\n                    // needs to be executed and returned\r\n                }\r\n            }\r\n            // check for inequalities\r\n            switch(xType) {\r\n                case z.types.date:\r\n                    if (x.getTime() !== y.getTime()) {\r\n                        return false;\r\n                    }\r\n                    // check for extra properties stored on the Date object\r\n                    if (!_compareObject(x, y)) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case z.types.function:\r\n                    // if (!z.equals(z.functions.getBody(x), z.functions.getBody(y))) {\r\n                    //     // function body mismatch\r\n                    //     return false;\r\n                    // }\r\n                    // if (!z.equals(z.functions.getArgumentNames(x), z.functions.getArgumentNames(y))) {\r\n                    //     // function arguments mismatch\r\n                    //     return false;\r\n                    // }\r\n                    if (!_compareObject(x, y)) {\r\n                        // property mismatch on function\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case z.types.array:\r\n                    if (x.length !== y.length) {\r\n                        return false;\r\n                    }\r\n                    rc.push(x, y);\r\n                    for (var i = 0; i < x.length; i++) {\r\n                        if (!_equals(x[i], y[i])) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                    rc.pop();\r\n                    break;\r\n                case z.types.object:\r\n                case z.types.regexp:\r\n                    if (!_compareObject(x, y)) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                default:\r\n                    if (x !== y) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n            }\r\n            return true;\r\n        }\r\n        return _equals(x, y);\r\n    };\r\n\r\n    /**\r\n        Extends the properties on the provided arguments into the original item.\r\n        Any properties on the tail arguments will not overwrite\r\n        any existing properties on the first argument.\r\n        \r\n        @param {...any} var_args The tail items to smash.\r\n        @returns {any} A newly extended item.\r\n        @throws {error} An error is thrown if any of the provided arguments have different underlying types.\r\n    */\r\n    z.extend = function(/* arguments */) {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (args.length <= 0) {\r\n            return null;\r\n        }\r\n        if (args.length === 1) {\r\n            return args[0];\r\n        }\r\n        var target = args[0];\r\n        var callback = function(value, key, arg) {\r\n            if (!z.check.exists(target[key])) {\r\n                target[key] = args[i][key];\r\n            }\r\n            else {\r\n                if (z.check.isSmashable(target[key], arg[key])) {\r\n                    target[key] = z.smash(target[key], arg[key]);\r\n                }\r\n            }\r\n        };\r\n        for (var i = 1; i < args.length; i++) {\r\n            z.assert.isSmashable(target, args[i]);\r\n            z.forEach(args[i], callback);\r\n        }\r\n        return target;\r\n    };\r\n\r\n    /**\r\n        Iterates over an iterable object or array,\r\n        calling the provided method with the provided optional context,\r\n        as well as the value and the key for the current item.\r\n\r\n        @param {object|array|date|regexp} item The item over which to iterate.\r\n        @param {function} method The method to call for each iterated item.\r\n        @param {object} context The context to set to \"this\" for the method.\r\n        @returns {object|array|date|regexp} The reference to the original item.\r\n    */\r\n    z.forEach = function(item, method, context) {\r\n        var itemType = z.getType(item);\r\n        switch(itemType) {\r\n            case z.types.date:\r\n            case z.types.function:\r\n            case z.types.object:\r\n            case z.types.regexp:\r\n                for (var key in item) {\r\n                    if (item.hasOwnProperty(key)) {\r\n                        method.call(context, item[key], key, item);\r\n                    }\r\n                }\r\n                break;\r\n            case z.types.arguments:\r\n            case z.types.array:\r\n                for (var i = 0; i < item.length; i++) {\r\n                    method.call(context, item[i], i, item);\r\n                }\r\n                break;\r\n        }\r\n        return item;\r\n    };\r\n\r\n    /**\r\n        Smashes the properties on the provided arguments into the first argument.\r\n        Any properties on the tail arguments will overwrite\r\n        any existing properties on the first argument.\r\n        \r\n        @param {...any} var_args The tail items to smash.\r\n        @returns {any} A newly smashed item.\r\n        @throws {error} An error is thrown if any of the provided arguments have different underlying types.\r\n    */\r\n    z.smash = function(/* arguments */) {\r\n        var args = Array.prototype.slice.call(arguments);\r\n        if (args.length <= 0) {\r\n            return null;\r\n        }\r\n        if (args.length === 1) {\r\n            return args[0];\r\n        }\r\n        var target = args[0];\r\n        var basis = args[args.length-1];\r\n        z.assert.isSmashable(target, basis);\r\n        var callback = function(value, key, arg) {\r\n            if (!z.check.exists(target[key])) { \r\n                target[key] = z.deepCopy(args[i][key]);\r\n            }\r\n            else {\r\n                if (z.check.isSmashable(target[key], arg[key])) {\r\n                    z.smash(target[key], arg[key]);\r\n                }\r\n            }\r\n        };\r\n        z.forEach(basis, function(value, key) {\r\n            // smash/copy the basis into the target regardless of key existence\r\n            // this is to ensure that the properties of the final object take priority\r\n            if (z.check.isSmashable(target[key], basis[key])) {\r\n                z.smash(target[key], basis[key]); \r\n            }\r\n            else {\r\n                target[key] = z.deepCopy(basis[key]);\r\n            }\r\n        });\r\n        for (var i = args.length-2; i >= 1; i--) { // skip the final object on the iteration\r\n            z.assert.isSmashable(args[i], target);\r\n            z.forEach(args[i], callback);\r\n        }\r\n        return target;\r\n    };\r\n\r\n    /**\r\n        Converts a string representation of a \r\n        lambda function into a javascript function\r\n    \r\n        Note: This is awkward and inefficient, and should absolutely be replaced\r\n        by arrow functions when ECMAScript 6 is available.\r\n        \r\n        @param {null|function|string} [expression] The string representation of the expression to convert into a function.\r\n        @returns {function} \r\n             If a string expression is provided, the function for the expression. \r\n             If a function is provided, then return the function.\r\n             If expression is null or undefined, return functions.identity.\r\n     */\r\n    z.lambda = function(expression) {\r\n        if (expression == null) {\r\n            return z.functions.identity;\r\n        }\r\n        else if (z.getType(expression) === z.types.function) {\r\n            return expression;\r\n        }\r\n        else if (z.getType(expression) === z.types.string) {\r\n            if (z.equals(expression, \"\")) {\r\n                return z.functions.identity;\r\n            }\r\n            // else if (expression.indexOf(\"=>\") > -1) {\r\n            //     var match = expression.match(z.functions.matcher);\r\n            //     var args = match[1] || [];\r\n            //     var body = match[2];\r\n            //     return new Function(args, \"return \" + body + \";\").bind(arguments.callee.caller);\r\n            // }\r\n        }\r\n        // throw error or assume equality check? \r\n        // see unitTests.removeAll for methods using the default equals\r\n        return function(x) { return z.equals(expression, x); }; \r\n    };\r\n\r\n    /**\r\n        Executes setup methods based on the provided settings object.\r\n         \r\n        @param {object} settings The settings object.\r\n        @param {boolean} [settings.useArrayExtensions]  A boolean flag used to determine whether or not to extend Array.prototype.\r\n        @param {boolean} [settings.useNumberExtensions] A boolean flag used to determine whether or not to extend Number.prototype.\r\n        @param {boolean} [settings.useObjectExtensions] A boolean flag used to determine whether or not to extend Object.prototype.\r\n        @param {object} [settings.defaultLogger] The default logger interface to apply to the default zUtil.log class.\r\n    */\r\n    z.setup = function(settings) {\r\n        settings = settings || {};\r\n        if (z.setup.initArrays)\r\n            z.setup.initArrays(settings.useArrayExtensions);\r\n        if (z.setup.initFunctions)\r\n            z.setup.initFunctions(settings.useFunctionExtensions);\r\n        if (z.setup.initNumbers)\r\n            z.setup.initNumbers(settings.useNumberExtensions);\r\n        if (z.setup.initObjects)\r\n            z.setup.initObjects(settings.useObjectExtensions);\r\n        if (z.setup.initLogger)\r\n            z.setup.initLogger(settings.defaultLogger);\r\n    };\r\n\r\n    /**\r\n        Define constants for the library.\r\n     */\r\n    z.functions = {\r\n        \"identity\": function(x) { return x; }\r\n        , \"true\": function() { return true; }\r\n        , \"false\": function() { return false; }\r\n        , \"empty\": function() { }\r\n        , \"matcher\": /^(?:[(\\s*]*)?(\\w+(?:,\\s*\\w+)*)?(?:[)\\s*]*)?=>(?:\\s*)?(.*)$/\r\n    };\r\n    z.types = {\r\n        \"arguments\":    z.getType(arguments) \r\n        , \"array\":      z.getType([])\r\n        , \"boolean\":    z.getType(true)\r\n        , \"date\":       z.getType(new Date())\r\n        , \"function\":   z.getType(function(){})\r\n        , \"null\":       z.getType(null)\r\n        , \"number\":     z.getType(0)\r\n        , \"object\":     z.getType({})\r\n        , \"string\":     z.getType(\"\")\r\n        , \"regexp\":     z.getType(new RegExp())\r\n        , \"undefined\":  z.getType(undefined)\r\n    };\r\n\r\n    return (function() {\r\n        var root = (\r\n            typeof window !== 'undefined' ?\r\n                window\r\n                : typeof global !== 'undefined' ?\r\n                    global \r\n                    : this\r\n        );\r\n        if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n            root.z = z;\r\n            define(function() {\r\n                return z;\r\n            });\r\n        }\r\n        else if (typeof module !== 'undefined') {\r\n            if (typeof module.exports !== 'undefined') {\r\n                module.exports = z;\r\n            }\r\n        }\r\n        else {\r\n            // assume browser, expose to root\r\n            root.z = z;\r\n        }\r\n        return z;\r\n    })();\r\n})();","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        var arrays = z.arrays = {};\r\n\r\n        /**\r\n            Performs the provided method on each element of array,\r\n            using the previous result and the current item as\r\n            arguments for the method.\r\n            \r\n            Note that we could really just use Array.prototype.reduce -- same thing.\r\n            \r\n            @this {array}\r\n            @param {array} source The original array.\r\n            @param {function} func A function used to return the result of an operation on the current element and previous result.\r\n            @param {function} [seed] An optional seed to use as the the first argument with the first item in the array.\r\n            @returns The result of the aggregate function on the array.\r\n        */\r\n        arrays.aggregate = function(/* source, func, seed */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var func = arguments[argsIterator++];\r\n            var seed = arguments[argsIterator++];\r\n            z.assert.isNonEmptyArray(source);\r\n            var result;\r\n            func = z.lambda(func);\r\n            if (seed == null) {\r\n                result = source[0];\r\n            }\r\n            else {\r\n                result = func(seed, source[0]);\r\n            }\r\n            for (var i = 1; i < source.length; i++) {\r\n                result = func(result, source[i]);\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Searches the array for at least one item \r\n            which either exists, or matches a given predicate.\r\n            \r\n            @this {Array}\r\n            @param {array} source The original array.\r\n            @param {function} [predicate] A predicate used to find matches for the array. This function should return a truthy value.\r\n            @returns True if at least one item is found which exists or matches the given predicate, else false.\r\n        */\r\n        arrays.any = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            if (predicate == null) {\r\n                return source.length > 0;\r\n            }\r\n            predicate = z.lambda(predicate);\r\n            for (var i = 0; i < source.length; i++) {\r\n                if (predicate(source[i])) {\r\n                    return true;\r\n                }    \r\n            }\r\n            return false;\r\n        };\r\n\r\n        /**\r\n            Collects the average of an array of numbers or a given numeric property for an array of objects.\r\n            \r\n            @this {Array}\r\n            @param {string} [selector] A property name.\r\n            @returns The average of either the array itself, or the given property.\r\n        */\r\n        arrays.average = function(/* source, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            return arrays.sum(source, selector) / source.length;\r\n        };\r\n\r\n        /**\r\n            Searches the array for items for a match for a given item.\r\n            \r\n            @this {Array}\r\n            @param {any} item The item for which to search. or the predicate to use for matching.\r\n            @param {function} [selector] The optional selector function used to select an item from the array for matching.\r\n            @returns True if the item is found, else false.\r\n        */\r\n        arrays.contains = function(/* source, item, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var item = arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var comparer;\r\n            var i;\r\n            if (z.check.isFunction(item)) \r\n                comparer = function(x) { return item(x); };\r\n            else\r\n                comparer = function(x, y) { return z.equals(x, y); };\r\n\r\n            if (selector == null) {\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (comparer(source[i], item)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                selector = z.lambda(selector);\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (comparer(selector(source[i]), item)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        /**\r\n            Searches the array for items for matches for a given item.\r\n            \r\n            @this {Array}\r\n            @param {any} item The item for which to search.\r\n            @param {function} [selector] The optional selector function used to select an item from the array for matching.\r\n            @returns The count of the matches found.\r\n        */\r\n        arrays.count = function(/* source, item, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var item = arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var count = 0;\r\n            var comparer;\r\n            var i;\r\n            if (z.check.isFunction(item)) \r\n                comparer = function(x) { return item(x); };\r\n            else\r\n                comparer = function(x, y) { return z.equals(x, y); };\r\n\r\n            if (selector == null) {\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (comparer(source[i], item)) {\r\n                        count++;\r\n                    }\r\n                } \r\n            }\r\n            else {\r\n                selector = z.lambda(selector);\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (comparer(selector(source[i]), item)) {\r\n                        count++;\r\n                    }\r\n                }\r\n            }\r\n            return count;\r\n        };\r\n\r\n        /**\r\n            Builds a deep copy of the original array.\r\n            To be used for the Array.prototype extension.\r\n\r\n            @this {array} The array from which to build the deep copy.\r\n            @returns {any} A deep copy of the original array.\r\n            @throws {error} An error is thrown if the recursive object stack grows greater than 1000.\r\n        */\r\n        var _deepCopy = function() {\r\n            return z.deepCopy(this);\r\n        };\r\n\r\n        /**\r\n            Builds a compressed array from the original, containing only distinct items.\r\n            If a selector is given, then uniqueness will be determined by \r\n            comparing the selected properties from objects on the array.\r\n            \r\n            @this {array}\r\n            @param {string} [selector] A property name.\r\n            @returns {array} A deep copied, distinct set of items.\r\n        */\r\n        arrays.distinct = function(/* source, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var result = [];\r\n            var i;\r\n            if (selector == null) {\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (!result.contains(source[i])) {\r\n                        result.push(source[i]);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                selector = z.lambda(selector);\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (!result.contains(selector(source[i]), selector)) {\r\n                        result.push(source[i]);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Compares the equality of the original and a provided array.\r\n            To be used for the Array.prototype extension.\r\n\r\n            @this {array} The first array to compare.\r\n            @param {array} arr2 The second array to compare.\r\n            @returns {boolean} True if both arrays contain equal items, false if not.\r\n            @throws {error} An error is thrown if the recursive function stack grows greater than 1000.\r\n        */\r\n        var _equals = function(arr2) {\r\n            return z.equals(this, arr2);\r\n        };\r\n\r\n        /**\r\n            Collects the first available value on the array\r\n            optionally based on a given predicate. \r\n            \r\n            @this {array} The array on which to search for a max value.\r\n            @param {function} [predicate] The optional predicate used to find the first match.\r\n            @returns {any} If no predicate is available, then the first item. If the predicate is available, the first item which matches.\r\n        */\r\n        arrays.first = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            if (predicate == null) {\r\n                if (source.length > 0) {\r\n                    return source[0];\r\n                }\r\n            }\r\n            else {\r\n                predicate = z.lambda(predicate);\r\n                for (var i = 0; i < source.length; i++) {\r\n                    if (predicate(source[i])) {\r\n                        return source[i];\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n\r\n        /**\r\n            Sets up two arrays of objects to be joined together.\r\n            \r\n            @this {array.<object>} The initial left array used for the inner join\r\n            @param {array.<object>} [rightArray] The secondary right array used for the inner join.\r\n            @returns {function} Returns an object containing the on method to be called after original inner join setup.\r\n        */\r\n        arrays.innerJoin = function(/* leftArray, rightArray */) {\r\n            var argsIterator = 0;\r\n            var leftArray = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var rightArray = arguments[argsIterator++];\r\n            // z.check.isNonEmptyArray(rightArray);\r\n            return {\r\n                /**\r\n                    Joins two arrays of objects together based on a provided predicate.\r\n\r\n                    @param {function} predicate The predicate used to find matches between the left and right arrays.\r\n                    @returns {array.<object>} The inner joined collection of left and right arrays.\r\n                */\r\n                on: function(predicate) {\r\n                    var target = [];\r\n                    predicate = z.lambda(predicate);\r\n                    for (var i = 0; i < leftArray.length; i++) {\r\n                        z.check.isObject(leftArray[i]);\r\n                        for (var k = 0; k < rightArray.length; k++) {\r\n                            z.check.isObject(rightArray[k]);\r\n                            if (predicate(leftArray[i], rightArray[k])) {\r\n                                target.push(z.smash({}, leftArray[i], rightArray[k]));\r\n                            }\r\n                        }\r\n                    }\r\n                    return target;\r\n                }\r\n            };\r\n        };\r\n\r\n        /**\r\n            Checks to see if an array is empty.\r\n            \r\n            @param {array} source The array to check for emptiness.\r\n            @returns {boolean} True if the array contains no elements, or a combination of undefined or null elements, false if not.\r\n        */\r\n        arrays.isEmpty = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            if (source.length < 1) {\r\n                return true;\r\n            }\r\n            for (var i = 0; i < source.length; i++) {\r\n                if (z.check.exists(source[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        /**\r\n            Checks to see if an array is full.\r\n            \r\n            @param {array} source The array to check for emptiness.\r\n            @returns {boolean} True if the array contains no elements, or a combination of undefined or null elements, false if not.\r\n        */\r\n        arrays.isFull = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            if (source.length < 1) {\r\n                return false;\r\n            }\r\n            for (var i = 0; i < source.length; i++) {\r\n                if (!z.check.exists(source[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        /**\r\n            Collects the last available value on the array\r\n            optionally based on a given predicate. \r\n            \r\n            @this {array} The array on which to search for a max value.\r\n            @param {function} [predicate] The optional predicate used to find the last match.\r\n            @returns {any} If no predicate is available, then the last item. If the predicate is available, the last item which matches.\r\n        */\r\n        arrays.last = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            if (predicate == null) {\r\n                if (source.length > 0) {\r\n                    return source[source.length-1];\r\n                }\r\n            }\r\n            else {\r\n                predicate = z.lambda(predicate);\r\n                for (var i = source.length-1; 0 <= i; i--) {\r\n                    if (predicate(source[i])) {\r\n                        return source[i];\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n\r\n        /**\r\n            Collects the maximum value of an array of numbers \r\n            or a given numeric property for an array of objects.\r\n            \r\n            @this {array} The array on which to search for a max value.\r\n            @param {string} [selector] A property name.\r\n            @returns The maximum value of either the array itself, or the given property.\r\n        */\r\n        arrays.max = function(/* source, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var maxValue = Number.MIN_VALUE;\r\n            var selected;\r\n            var i;\r\n            if (selector != null) {\r\n                selector = z.lambda(selector);\r\n                for (i = 0; i < source.length; i++) {\r\n                    selected = selector(source[i]);\r\n                    if (z.check.isNumber(selected) && maxValue < selected) {\r\n                        maxValue = selected;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (i = 0; i < source.length; i++) {\r\n                    selected = source[i];\r\n                    if (z.check.isNumber(selected) && maxValue < selected) {\r\n                        maxValue = selected;\r\n                    }\r\n                }\r\n            }\r\n            return maxValue;\r\n        };\r\n\r\n        /**\r\n            Collects the minimum value of an array of numbers \r\n            or a given numeric property for an array of objects.\r\n            \r\n            @param {array} source The source array from which to collect min value.\r\n            @param {function} [selector] A selector function.\r\n            @returns The minimum value of either the array itself, or the given property.\r\n        */\r\n        arrays.min = function(/* source, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var minValue = Number.MAX_VALUE;\r\n            var selected;\r\n            var i;\r\n            if (selector != null) {\r\n                selector = z.lambda(selector);\r\n                for (i = 0; i < source.length; i++) {\r\n                    selected = selector(source[i]);\r\n                    if (z.check.isNumber(selected) && selected < minValue) {\r\n                        minValue = selected;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (i = 0; i < source.length; i++) {\r\n                    selected = source[i];\r\n                    if (z.check.isNumber(selected) && selected < minValue) {\r\n                        minValue = selected;\r\n                    }\r\n                }\r\n            }\r\n            return minValue;\r\n        };\r\n\r\n        /**\r\n            Mutates the provided array based on a given mutator function.\r\n            Each item of the array will be passed through the mutator function,\r\n            setting the return from the mutator back to the original array index.\r\n            \r\n            @param {array} source The source array from which to collect min value.\r\n            @param {function} mutator The mutator function.\r\n            @returns A reference to the original (now mutated) array.\r\n        */\r\n        arrays.mutate = function(/* source, mutator */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var mutator = arguments[argsIterator++];\r\n            mutator = z.lambda(mutator);\r\n            if (z.check.isFunction(mutator)) {\r\n                z.forEach(source, function(val, key) {\r\n                    source[key] = mutator(source[key]);\r\n                });\r\n            }\r\n            return source;\r\n        };\r\n\r\n        /**\r\n            Creates an deep copy of the original array of objects, ordered by the given key. \r\n            \r\n            @this {Object[]}\r\n            @param {function|string} selector The method or lambda string used to select a key by which to order.\r\n            @param {function} [predicate] A predicate used to determine whether one object is greater than, less than, or equal to another. If no predicate is defined, then the javascript > and < comparators are used.\r\n        */\r\n        arrays.orderBy = function(/* source, selector, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            selector = z.lambda(selector);\r\n            predicate = predicate || function(x, y) {\r\n                return ((selector(x) > selector(y)) ? 1 : (selector(x) < selector(y)) ? -1 : 0);\r\n            };\r\n            var containsKey = source.where(function(obj) { return selector(obj) != null; });\r\n            var missingKey = source.where(function(obj) { return selector(obj) == null; }); // don't bother sorting items with null or undefined keys\r\n            containsKey.quicksort(predicate); \r\n            return containsKey.concat(missingKey);\r\n        };\r\n\r\n        /**\r\n            Sorts the original, given array in place by using the quicksort algorithm.\r\n            \r\n            @this {Array}\r\n            @param {string|function} [predicate] A predicate used to determine whether one item is greater than, less than, or equal to another. If no predicate is defined, then the javascript > and < comparators are used.\r\n        */\r\n        arrays.quicksort = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            if (z.getType(predicate) === z.types.string) {\r\n                predicate = z.lambda(predicate);\r\n            }\r\n            else {\r\n                // dont accidentally take z.functions.identity - use this else statement\r\n                predicate = predicate || function(x, y) {\r\n                    return (x > y) ? 1 : ((x < y) ? -1 : 0);\r\n                };\r\n            }\r\n\r\n            var comparer = function(x, y, xIndex, yIndex) {\r\n                var c = predicate(x, y);\r\n                if (c === 0)\r\n                    return xIndex - yIndex;\r\n                return c;\r\n            };\r\n\r\n            // more efficient to declare the internal call outside and just pass params around?\r\n            // probably is -- more testing should be done here for optimization\r\n            var internalQuickSort = function(left, right) {\r\n                do {\r\n                    var i = left;\r\n                    var j = right;\r\n                    var pivot = Math.floor((left + right) / 2);\r\n                    var p = source[pivot];\r\n                    do {\r\n                        while ((i < source.length) && (comparer(source[i], p, i, pivot) < 0)) {\r\n                            i++;\r\n                        }\r\n                        while ((0 <= j) && (comparer(p, source[j], pivot, j) < 0)) {\r\n                            j--;\r\n                        }\r\n                        if (i > j) {\r\n                            break; // left index has crossed right index, stop the loop\r\n                        }\r\n                        if (i < j) {\r\n                            source.swap(i, j); // swap the indexes in the source\r\n                        }\r\n                        i++;\r\n                        j--;\r\n                    } while (i <= j);\r\n                    if ((j - left) <= (right - i)) {\r\n                        if (left < j) {\r\n                            internalQuickSort(left, j);\r\n                        }\r\n                        left = i;\r\n                    }\r\n                    else {\r\n                        if (i < right) {\r\n                            internalQuickSort(i, right);\r\n                        }\r\n                        right = j;\r\n                    }\r\n                } while (left < right);\r\n            };\r\n            internalQuickSort(0, this.length-1);\r\n        };\r\n\r\n        /**\r\n            Sorts the original, given array in place \r\n            by using the quicksort algorithm with three-way partitioning.\r\n            \r\n            @this {Array}\r\n            @param {string|function} [predicate] A predicate used to determine whether one item is greater than, less than, or equal to another. If no predicate is defined, then the javascript > and < comparators are used.\r\n        */\r\n        arrays.quicksort3 = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            if (z.getType(predicate) === z.types.string) {\r\n                predicate = z.lambda(predicate);\r\n            }\r\n            else {\r\n                // dont accidentally take z.functions.identity - use this else statement\r\n                predicate = predicate || function(x, y) {\r\n                    return (x > y) ? 1 : ((x < y) ? -1 : 0);\r\n                };\r\n            }\r\n            var internalQuickSort = function(left, right) {\r\n                var indexForLessThan = left;\r\n                var indexForGreaterThan = right;\r\n                var pivot = source[left];\r\n                var indexForIterator = left+1;\r\n                while (indexForIterator <= indexForGreaterThan) {\r\n                    var cmp = predicate(source[indexForIterator], pivot);\r\n                    if (cmp < 0) {\r\n                        source.swap(indexForLessThan++, indexForIterator++);\r\n                    }\r\n                    else if (cmp > 0) {\r\n                        source.swap(indexForIterator, indexForGreaterThan--);\r\n                    }\r\n                    else {\r\n                        indexForIterator++;\r\n                    }\r\n                }\r\n                if (left < indexForLessThan-1) {\r\n                    internalQuickSort(left, indexForLessThan-1);\r\n                }\r\n                if (indexForGreaterThan+1 < right) {\r\n                    internalQuickSort(indexForGreaterThan+1, right);\r\n                }\r\n            };\r\n            internalQuickSort(0, this.length-1);\r\n        };\r\n\r\n        /**\r\n            Removes the first element from an array which matches a provided predicate.\r\n             \r\n            @param {array} source The source array from which to remove an element.\r\n            @param {function} predicate The method used to determine element removal.\r\n            @returns {array} The reference to the original array.\r\n        */\r\n        arrays.remove = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            predicate = z.lambda(predicate);\r\n            for (var i = 0; i < source.length; i++) {\r\n                if (predicate(source[i])) {\r\n                    source.splice(i, 1);\r\n                }\r\n            }\r\n            return source;\r\n        };\r\n\r\n        /**\r\n            Removes elements from an array based on a provided predicate.\r\n            Traverses the array backwards, as it modifies the array which is currently being iterated.\r\n             \r\n            @param {array} source The source array.\r\n            @param {function|string} predicate The method or lambda string used to determine element removal.\r\n            @returns {number} The count of removed items.\r\n        */\r\n        arrays.removeAll = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            var removalCount = 0;\r\n            predicate = z.lambda(predicate);\r\n            for (var i = source.length-1; i > -1; i--) {\r\n                if (predicate(source[i])) {\r\n                    source.splice(i, 1);\r\n                    removalCount++;\r\n                }\r\n            }\r\n            return removalCount;\r\n        };\r\n\r\n        /**\r\n            Projects a selected set of elements from an array of objects into a new array of new objects.\r\n            \r\n            @param {array} source The source array.\r\n            @param {(string|function|string[])} selectors A property name, function for selecting properties, or an array of property names.\r\n            @returns {array} An array of objects, containing the properties specified by selectors.\r\n        */\r\n        arrays.select = function(/* source, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var result = [];\r\n            selector = z.lambda(selector);\r\n            for (var i = 0; i < source.length; i++) {\r\n                result.push(selector(source[i]));\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Shuffles an array using the Fisher-Yates algorithm.\r\n            Note that the original array in the provided reference will be shuffled.\r\n\r\n            @param {array} source The source array to be shuffled.\r\n            @returns {array} source The shuffled array.\r\n        */\r\n        arrays.shuffle = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            for (var i = source.length-1; i >= 0; i--) {\r\n                arrays.swap(source, i, Math.floor(Math.random() * i));\r\n            }\r\n            return source; // note that the original array will be shuffled -- return a reference to it anyways\r\n        };\r\n\r\n        /**\r\n            Takes and returns the items of the array\r\n            starting at the provided index.\r\n            \r\n            @param {array} source The source array over which to iterate.\r\n            @param {number} index The index to start at.\r\n            @returns {array} An array containing the taken items.\r\n        */\r\n        arrays.skip = function(/* source, index */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var index = arguments[argsIterator++];\r\n            var result = [];\r\n            if (index < 0) {\r\n                index = 0; // consider logic for negative skips skipping items from the back\r\n            }\r\n            for (var i = 0; i < source.length - index && index <= source.length; i++) {\r\n                result[i] = source[i+index];\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Internal method for assistance with recursively building\r\n            a set of subsets whose values all add up to the specified target.\r\n\r\n            @param {array<number>} remaining The remaining unused values array for which to calculate a set of subsets.\r\n            @param {number} target The target for each subset's sum.\r\n            @param {array<number>} partial The array containing a potential subset of numbers whose sum adds to the target.\r\n            @param {array<array<number>>} successes The reference to the array containing all successfully found subsets.\r\n            @returns {array<array<number>>} The set of subsets.\r\n        */\r\n        function _internalSubsetSum(remaining, target, selector, partial, successes) {\r\n            var s = partial.sum(selector);\r\n            if (s === target) {\r\n                successes.push(partial); // partial is a success!\r\n                return; // found a success - end of path\r\n            }\r\n            if (s > target) {\r\n                return; // too high - bad path\r\n            }\r\n            for (var i = 0; i < remaining.length; i++) {\r\n                var newRemaining = [];\r\n                var n = remaining[i];\r\n                for (var j = i+1; j < remaining.length; j++) {\r\n                    newRemaining.push(remaining[j]);\r\n                }\r\n                var newPartial = partial.deepCopy(); // will this be too inefficient? we could use slice for a shallow copy, if necessary\r\n                newPartial.push(n);\r\n                _internalSubsetSum(newRemaining, target, selector, newPartial, successes);\r\n            }\r\n            return successes;\r\n        }\r\n\r\n        /**\r\n            Builds an array of arrays, notating a set of subsets\r\n            whose values all add up to the specified target.\r\n\r\n            @param {array<number>} source The source array for which to calculate a set of subsets.\r\n            @param {number} target The target for each subset's sum.\r\n            @returns {array<array<number>>} The set of subsets.\r\n        */\r\n        arrays.subsetSum = function(/* source, target, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var target = arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            if (!z.check.isFunction(selector)) {\r\n                selector = z.functions.identity;\r\n                // source = source.select(selector);\r\n            }\r\n            return _internalSubsetSum(source, target, selector, [], []);\r\n        };\r\n\r\n        /**\r\n            Builds a summation of an array of numbers\r\n            or a given numeric property for an array of objects.\r\n            \r\n            @this {array}\r\n            @param {function|string} [selector] The method or lambda string used to select a property name for an array of objects.\r\n            @returns A summation of either the array itself, or the given property.\r\n        */\r\n        arrays.sum = function(/* source, selector */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var selector = arguments[argsIterator++];\r\n            var sum = 0;\r\n            var i;\r\n            if (selector != null) {\r\n                selector = z.lambda(selector);\r\n                for (i = 0; i < source.length; i++) {\r\n                    var selection = selector(source[i]);\r\n                    if (z.check.isNumber(selection)) {\r\n                        sum += selection;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (i = 0; i < source.length; i++) {\r\n                    if (z.check.isNumber(source[i])) {\r\n                        sum += (source[i]);\r\n                    }\r\n                }\r\n            }\r\n            return sum;\r\n        };\r\n\r\n        /**\r\n            Swaps two array items located at the provided indices.\r\n            Note that the assertions can be dropped to improve performance.\r\n            \r\n            @this {array}\r\n            @param {number} indexA The first index.\r\n            @param {number} indexB The second index.\r\n            @returns {void}\r\n         */\r\n        arrays.swap = function(/* source, indexA, indexB */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var indexA = arguments[argsIterator++];\r\n            var indexB = arguments[argsIterator++];\r\n            var temp = source[indexA];\r\n            source[indexA] = source[indexB];\r\n            source[indexB] = temp;\r\n        };\r\n\r\n        /**\r\n            Takes the number of provided items from the array,\r\n            starting at the first element.\r\n            \r\n            @this {array}\r\n            @param {number} count The number of items to take.\r\n            @returns {array} An array containing the taken items.\r\n        */\r\n        arrays.take = function(/* source, count */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var count = arguments[argsIterator++];\r\n            var result = [];\r\n            if (count < 0) {\r\n                count = 0; // consider logic to allow negative count to count from the back of the array\r\n            }\r\n            for (var i = 0; i < count && i < source.length; i++) {\r\n                result[i] = source[i];\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Takes items from the array until\r\n            the predicate no longer matches.\r\n            \r\n            @this {array}\r\n            @param {function|string} predicate The method or lambda string used to determine when to halt collection from the source array.\r\n            @returns {array} An array containing the taken items.\r\n        */\r\n        arrays.takeWhile = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            var result = [];\r\n            predicate = z.lambda(predicate);\r\n            for (var i = 0; i < count; i++) {\r\n                if (!predicate(source[i])) break;\r\n                result.push(source[i]);\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Builds an array of objects from the original array which\r\n            contains items that meet the conditions given by the predicate.\r\n\r\n            Note that this is really the same thing as Array.filter.\r\n            \r\n            @this {array}\r\n            @param {function} predicate A predicate used to determine whether or not to take an object on the array.\r\n            @returns {array} A deep copied array of objects which match the predicate.\r\n        */\r\n        arrays.where = function(/* source, predicate */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var predicate = arguments[argsIterator++];\r\n            predicate = z.lambda(predicate);\r\n            var result = [];\r\n            for (var i = 0; i < source.length; i++) {\r\n                if (predicate(source[i], i, source)) {\r\n                    result.push(source[i]);\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Builds a new array by executing a provided method \r\n            with the provided two arrays and placing the result the new array.\r\n            \r\n            @param {arr1} array The first array to use for the zipping method.\r\n            @param {arr2} array The second array to use for the zipping method.\r\n            @param {method} method The method used to execute and return a result using items on both of the original arrays.\r\n            @returns {array} An array with the zipped results.\r\n        */\r\n        arrays.zip = function(/* arr1, arr2, method */) {\r\n            var argsIterator = 0;\r\n            var arr1 = z.getType(this) === z.types.array ? this : arguments[argsIterator++];\r\n            var arr2 = arguments[argsIterator++];\r\n            var method = arguments[argsIterator++];\r\n            method = z.lambda(method);\r\n            var source = this;\r\n            var result = [];\r\n            for (var i = 0; i < source.length; i++) {\r\n                result.push(method(arr1[i], arr2[i]));\r\n            }\r\n            return result;\r\n        };\r\n\r\n        /**\r\n            Initializes all pre-defined methods\r\n            as non-enumerable and non-writable properties\r\n            located on the Array.prototype.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initArrays = function(usePrototype) {\r\n            if (!!usePrototype) {\r\n                z.defineProperty(Array.prototype, \"aggregate\", { enumerable: false, writable: true, value: arrays.aggregate });\r\n                z.defineProperty(Array.prototype, \"any\", { enumerable: false, writable: true, value: arrays.any });\r\n                z.defineProperty(Array.prototype, \"average\", { enumerable: false, writable: true, value: arrays.average });\r\n                z.defineProperty(Array.prototype, \"contains\", { enumerable: false, writable: true, value: arrays.contains });\r\n                z.defineProperty(Array.prototype, \"count\", { enumerable: false, writable: true, value: arrays.count });\r\n                z.defineProperty(Array.prototype, \"deepCopy\", { enumerable: false, writable: true, value: _deepCopy });\r\n                z.defineProperty(Array.prototype, \"distinct\", { enumerable: false, writable: true, value: arrays.distinct });\r\n                z.defineProperty(Array.prototype, \"equals\", { enumerable: false, writable: true, value: _equals });\r\n                z.defineProperty(Array.prototype, \"first\", { enumerable: false, writable: true, value: arrays.first });\r\n                z.defineProperty(Array.prototype, \"innerJoin\", { enumerable: false, writable: true, value: arrays.innerJoin });\r\n                z.defineProperty(Array.prototype, \"isEmpty\", { enumerable: false, writable: true, value: arrays.isEmpty });\r\n                z.defineProperty(Array.prototype, \"isFull\", { enumerable: false, writable: true, value: arrays.isFull });\r\n                z.defineProperty(Array.prototype, \"last\", { enumerable: false, writable: true, value: arrays.last });\r\n                z.defineProperty(Array.prototype, \"max\", { enumerable: false, writable: true, value: arrays.max });\r\n                z.defineProperty(Array.prototype, \"min\", { enumerable: false, writable: true, value: arrays.min });\r\n                z.defineProperty(Array.prototype, \"mutate\", { enumerable: false, writable: true, value: arrays.mutate });\r\n                z.defineProperty(Array.prototype, \"orderBy\", { enumerable: false, writable: true, value: arrays.orderBy });\r\n                z.defineProperty(Array.prototype, \"quicksort\", { enumerable: false, writable: true, value: arrays.quicksort });\r\n                z.defineProperty(Array.prototype, \"quicksort3\", { enumerable: false, writable: true, value: arrays.quicksort3 });\r\n                z.defineProperty(Array.prototype, \"remove\", { enumerable: false, writable: true, value: arrays.remove });\r\n                z.defineProperty(Array.prototype, \"removeAll\", { enumerable: false, writable: true, value: arrays.removeAll });\r\n                z.defineProperty(Array.prototype, \"select\", { enumerable: false, writable: true, value: arrays.select });\r\n                z.defineProperty(Array.prototype, \"shuffle\", { enumerable: false, writable: true, value: arrays.shuffle });\r\n                z.defineProperty(Array.prototype, \"skip\", { enumerable: false, writable: true, value: arrays.skip });\r\n                z.defineProperty(Array.prototype, \"subsetSum\", { enumerable: false, writable: true, value: arrays.subsetSum });\r\n                z.defineProperty(Array.prototype, \"sum\", { enumerable: false, writable: true, value: arrays.sum });\r\n                z.defineProperty(Array.prototype, \"swap\", { enumerable: false, writable: true, value: arrays.swap });\r\n                z.defineProperty(Array.prototype, \"take\", { enumerable: false, writable: true, value: arrays.take });\r\n                z.defineProperty(Array.prototype, \"takeWhile\", { enumerable: false, writable: true, value: arrays.takeWhile });\r\n                z.defineProperty(Array.prototype, \"where\", { enumerable: false, writable: true, value: arrays.where });\r\n                z.defineProperty(Array.prototype, \"zip\", { enumerable: false, writable: true, value: arrays.zip });\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        /*\r\n            AssertionError extension of Error, since certain libraries (eg gulp-mocha)\r\n            expect any assertion errors to be thrown to have a name of 'AssertionError'.\r\n        */\r\n        var AssertionError = function(message) {\r\n            if (!this instanceof AssertionError)\r\n                return new AssertionError(message);\r\n            if (Error && Error.captureStackTrace)\r\n                Error.captureStackTrace(this, this.constructor); // NodeJS style stack trace\r\n            this.name = 'AssertionError';\r\n            this.message = message || 'Unknown AssertionError';\r\n        };\r\n        AssertionError.prototype = Object.create(Error.prototype, {\r\n            constructor: {\r\n                value: AssertionError,\r\n                enumerable: false,\r\n                writable: true,\r\n                configurable: true\r\n            }\r\n        });\r\n\r\n        /**\r\n            Executes an assertion for a given condition.\r\n            \r\n            @param {boolean|function} condition The item used to determine whether or not an assertion passed.\r\n            @param {string} [message] The overridden message to use when throwing an error. If none is provided, then the condition is used as a message.\r\n            @returns {void}\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var assert = function(condition, message) {\r\n            // var parent = arguments.callee.caller;\r\n            if (z.getType(condition) === z.types.function) {\r\n                if (!condition()) {\r\n                    if (message) throw new Error(message);\r\n                    else {\r\n                        var functionString = condition.toString();\r\n                        var functionBody = functionString.substring(functionString.indexOf(\"{\") + 1, functionString.lastIndexOf(\"}\")).trim();\r\n                        throw new AssertionError(\"Assertion failed: \" + functionBody);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (!condition) {\r\n                    if(message) throw new AssertionError(message);\r\n                    else        throw new AssertionError(\"Assertion failed: \" + String(condition));\r\n                } // end if (!condition)\r\n            }\r\n        };\r\n\r\n        /**\r\n            Asserts that all of the arguments provided for a method existing.\r\n            \r\n            @param {string} var_args The arguments provided to a method.\r\n            @returns {boolean} True, if the assertion passes.\r\n        */\r\n        var argsNotNull = function() {\r\n            assert(function() { return z.check.argsNotNull.apply(this, arguments); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is not equal to null or undefined.\r\n            \r\n            @param {any} value The value to check for null or undefined values.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the value is equal to null or undefined.\r\n        */\r\n        var exists = function(value) {\r\n            assert(function() { return z.check.exists(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is an array type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isArray = function(value) {\r\n            assert(function() { return z.check.isArray(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a boolean type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isBoolean = function(value) {\r\n            assert(function() { return z.check.isBoolean(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a date type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isDate = function(value) {\r\n            assert(function() { return z.check.isDate(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a function type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isFunction = function(value) {\r\n            assert(function() { return z.check.isFunction(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a non-empty array.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isNonEmptyArray = function(value) {\r\n            assert(function() { return z.check.isNonEmptyArray(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a number type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isNumber = function(value) {\r\n            assert(function() { return z.check.isNumber(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is an object type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isObject = function(value) {\r\n            assert(function() { return z.check.isObject(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a reference type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isReference = function(value) {\r\n            assert(function() { return z.check.isReference(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided arguments are all \r\n            the same type of either arrays, functions, or objects.\r\n            \r\n            @param {...array|object|function} var_args The items to check for smashability.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isSmashable = function(/* ... arguments */) {\r\n            var args = arguments; // keep a pointer, so we can pass them into the anonymous function\r\n            assert(function() { return z.check.isSmashable.apply(undefined, args); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a string type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True if the value is a string, false if not.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isString = function(value) {\r\n            assert(function() { return z.check.isString(value); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a provided type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @param {string} type The name of the type for which to check.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isType = function(value, type) {\r\n            assert(function() { return z.check.isType(value, type); });\r\n        };\r\n\r\n        /**\r\n            Asserts that the provided value is a value (non-reference) type.\r\n            \r\n            @param {any} value The value on which to check the assertion.\r\n            @returns {boolean} True, if the assertion passes.\r\n            @throws {error} An error is thrown if the assertion fails.\r\n        */\r\n        var isValue = function(value) {\r\n            assert(function() { return z.check.isValue(value); });\r\n        };\r\n\r\n\r\n        /**\r\n            A wrapper class used to hold and execute different assertion methods.\r\n\r\n            @class Contains a provided set of assertions.\r\n         */\r\n        var Asserter = (function() {\r\n\r\n            /**\r\n                Creates a new Asserter class.\r\n\r\n                @constructor\r\n                @param {object} logger The interface containing the expected log methods.\r\n                @param {bool} [enableDebugLogging] An override for enabling debug logging on Log class creation.\r\n            */\r\n            function Asserter() {\r\n\r\n                /**\r\n                    Extends a function into an Asserter interface with\r\n                    the pre-determined, privately stored properties,\r\n                    returning it back to the original Asserter() call.\r\n\r\n                    @returns {function} The extended function.\r\n                */\r\n                return (function(newAsserter) {\r\n                    /**\r\n                        The base Asserter function to be returned.\r\n                        Note that the base function can be called\r\n                        as a pass-through method for _assert without\r\n                        needing to directly call LogInterface.log()\r\n\r\n                        @param {any} [x] The item to extend and return to the Asserter class.\r\n                        @returns {any} The extended item.\r\n                    */\r\n                    z.defineProperty(newAsserter, \"argsNotNull\", { get: function() { return argsNotNull; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"exists\", { get: function() { return exists; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isArray\", { get: function() { return isArray; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isBoolean\", { get: function() { return isBoolean; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isDate\", { get: function() { return isDate; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isFunction\", { get: function() { return isFunction; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isNonEmptyArray\", { get: function() { return isNonEmptyArray; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isNumber\", { get: function() { return isNumber; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isObject\", { get: function() { return isObject; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isReference\", { get: function() { return isReference; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isSmashable\", { get: function() { return isSmashable; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isString\", { get: function() { return isString; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isType\", { get: function() { return isType; }, writeable: false });\r\n                    z.defineProperty(newAsserter, \"isValue\", { get: function() { return isValue; }, writeable: false });\r\n                    return newAsserter;\r\n                })(assert);\r\n            }\r\n\r\n            return Asserter;\r\n            \r\n        })();\r\n\r\n        z.classes.Asserter = Asserter;\r\n        z.assert = new z.classes.Asserter(); // add a default Log using the console as the logging interface\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        /**\r\n            Container for all utility checking methods.\r\n            \r\n            @class Contains all utility checking methods.\r\n        */\r\n        var check = function() {};\r\n\r\n        /**\r\n            Checks that all of the arguments provided for a method existing.\r\n            \r\n            @param {string} var_args The arguments provided to a method.\r\n            @returns {boolean} True, if the check passes.\r\n        */\r\n        check.argsNotNull = function() {\r\n            for (var i = 0; i < arguments.length; i++) {\r\n                if (arguments[i] == null) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is not equal to null or undefined.\r\n            \r\n            @param {any} value The value to check for null or undefined values.\r\n            @returns {boolean} True, if the check passes.\r\n            @throws {error} An error is thrown if the value is equal to null or undefined.\r\n        */\r\n        check.exists = function(value) {\r\n            return value != null;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is an array type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isArray = function(value) {\r\n            return z.getType(value) === z.types.array;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a boolean type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isBoolean = function(value) {\r\n            return z.getType(value) === z.types.boolean;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a date type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isDate = function(value) {\r\n            return z.getType(value) === z.types.date;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a function type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isFunction = function(value) {\r\n            return z.getType(value) === z.types.function;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a generator function type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isGeneratorFunction = function(value) {\r\n            return z.getType(value) === z.types.function && value.isGenerator();\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is an iterable type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isIterable = function(value) {\r\n            if (!z.check.exists(value)) return false;\r\n            var iterator = value[z.symbols.iterator] || value.prototype[z.symbols.iterator]; // will this always be on prototype?\r\n            return z.getType(iterator) === z.types.function;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a non-empty array.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isNonEmptyArray = function(value) {\r\n            return (z.check.exists(value) && z.getType(value) === z.types.array && value.length > 0);\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a number type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isNumber = function(value) {\r\n            return !isNaN(value); \r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is an object type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isObject = function(value) {\r\n            return z.getType(value) === z.types.object;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a reference type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isReference = function(value) {\r\n            switch (z.getType(value)) {\r\n                case z.types.array:\r\n                case z.types.date:\r\n                case z.types.function:\r\n                case z.types.generator:\r\n                case z.types.generatorFunction:\r\n                case z.types.object:\r\n                case z.types.regexp:\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        };\r\n\r\n        /**\r\n            Checks that the provided arguments are all \r\n            the same type of either arrays, functions, or objects.\r\n            \r\n            @param {...array|object|function} var_args The items to check for smashability.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isSmashable = function(/* ... arguments */) {\r\n            var args = Array.prototype.slice.call(arguments);\r\n\r\n            if (args.length < 1)\r\n                return false;\r\n     \r\n            var baseType = z.getType(args[0]);\r\n            if (!(baseType === z.types.array || baseType === z.types.object || baseType === z.types.function))\r\n                return false;\r\n\r\n            if (baseType === z.types.function)\r\n                baseType = z.types.object; // allow functions to be smashed onto objects, and vice versa\r\n\r\n            for (var i = 1; i < args.length; i++) {\r\n                var targetType = z.getType(args[i]);\r\n                if (targetType === z.types.function)\r\n                    targetType = z.types.object; // allow functions to be smashed onto objects, and vice versa\r\n\r\n                if (targetType !== baseType)\r\n                    return false;\r\n            }\r\n            return true;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a string type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isString = function(value) {\r\n            return z.getType(value) === z.types.string;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a provided type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @param {string} type The name of the type for which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isType = function(value, type) {\r\n            return z.getType(value) === type;\r\n        };\r\n\r\n        /**\r\n            Checks that the provided value is a value (non-reference) type.\r\n            \r\n            @param {any} value The value on which to check.\r\n            @returns {boolean} True if the check passes, false if not.\r\n        */\r\n        check.isValue = function(value) {\r\n            switch (z.getType(value)) {\r\n                case z.types.boolean:\r\n                case z.types.null: // value or reference?\r\n                case z.types.number:\r\n                case z.types.string:\r\n                case z.types.undefined: // value or reference?\r\n                    return true;\r\n                default:\r\n                    return false;\r\n            }\r\n        };\r\n\r\n        z.check = check;\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        /**\r\n            Executes a conversion for a given source and type.\r\n            \r\n            @param {any} source The item to convert.\r\n            @param {string} toType The type to which to convert.\r\n            @returns {any} The converted source.\r\n            @throws {error} An error is thrown if toType is not a string.\r\n        */\r\n        var convert = function(source, toType) {\r\n            z.assert.isString(toType);\r\n            switch (toType) {\r\n                case z.types.boolean: return toBoolean(source);\r\n                case z.types.date: return toDate(source);\r\n                case z.types.number: return toNumber(source);\r\n            }\r\n        };\r\n\r\n        /**\r\n            Executes a conversion to boolean for a given source.\r\n            \r\n            @param {any} source The item to convert.\r\n            @returns {boolean} The converted source.\r\n        */\r\n        var toBoolean = function(source) {\r\n            if (z.check.exists(source) && z.check.isFunction(source.toBoolean)) {\r\n                return source.toBoolean(); // allow override to be supplied directly on the source object\r\n            }\r\n            switch (z.getType(source)) {\r\n                case z.types.boolean:\r\n                    return source;\r\n                case z.types.string:\r\n                    switch (source.toLowerCase().trim()) {\r\n                        case \"false\":\r\n                        case \"0\":\r\n                        case \"\":\r\n                        case null:\r\n                        case undefined:\r\n                            return false;\r\n                        default:\r\n                            return true;\r\n                    }\r\n                    break;\r\n                default:\r\n                    return !!source;\r\n            }\r\n        };\r\n\r\n        /**\r\n            Executes a conversion to a date for a given source.\r\n            \r\n            @param {any} source The item to convert.\r\n            @returns {date} The converted source.\r\n        */\r\n        var toDate = function(source) {\r\n            if (z.check.exists(source) && z.check.isFunction(source.toDate)) {\r\n                return source.toDate();\r\n            }\r\n            switch (z.getType(source)) {\r\n                case z.types.date:\r\n                    return source;\r\n                case z.types.string:\r\n                    return new Date(Date.parse(source));\r\n                default:\r\n                    return new Date(Date.parse(source.toString()));\r\n            }\r\n        };\r\n\r\n        /**\r\n            Executes a conversion to a number for a given source.\r\n            \r\n            @param {any} source The item to convert.\r\n            @returns {boolean} The converted source.\r\n        */\r\n        var toNumber = function(source) {\r\n            if (z.check.exists(source) && z.check.isFunction(source.toNumber)) {\r\n                return source.toNumber(); // allow override to be supplied directly on the source object\r\n            }\r\n            switch (z.getType(source)) {\r\n                case z.types.number:\r\n                    return source;\r\n                default:\r\n                    return +source;\r\n            }\r\n        };\r\n\r\n        /**\r\n            A wrapper class used to hold and execute different assertion methods.\r\n\r\n            @class Contains a provided set of assertions.\r\n         */\r\n        var Converter = (function() {\r\n\r\n            /**\r\n                Creates a new Asserter class.\r\n\r\n                @constructor\r\n                @param {object} logger The interface containing the expected log methods.\r\n                @param {bool} [enableDebugLogging] An override for enabling debug logging on Log class creation.\r\n            */\r\n            function Converter() {\r\n\r\n                /**\r\n                    Extends a function into an Asserter interface with\r\n                    the pre-determined, privately stored properties,\r\n                    returning it back to the original Asserter() call.\r\n\r\n                    @returns {function} The extended function.\r\n                */\r\n                return (function(newConverter) {\r\n                    /**\r\n                        The base Asserter function to be returned.\r\n                        Note that the base function can be called\r\n                        as a pass-through method for _assert without\r\n                        needing to directly call LogInterface.log()\r\n\r\n                        @param {any} [x] The item to extend and return to the Asserter class.\r\n                        @returns {any} The extended item.\r\n                    */\r\n                    z.defineProperty(newConverter, \"toBoolean\", { get: function() { return toBoolean; }, writeable: false });\r\n                    z.defineProperty(newConverter, \"toDate\", { get: function() { return toDate; }, writeable: false });\r\n                    z.defineProperty(newConverter, \"toNumber\", { get: function() { return toNumber; }, writeable: false });\r\n                    return newConverter;\r\n                })(convert);\r\n            }\r\n\r\n            return Converter;\r\n            \r\n        })();\r\n\r\n        z.classes.Converter = Converter;\r\n        z.convert = new z.classes.Converter();\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        /**\r\n            A wrapper class used to register and execute custom named events.\r\n\r\n            @class Contains an internal list of registered events.\r\n        */\r\n        var Events = (function() {\r\n\r\n            /**\r\n                Creates a new Events class.\r\n\r\n                @constructor\r\n            */\r\n            function Events() {\r\n\r\n                var _eventList = [];\r\n\r\n                /**\r\n                    Calls any registered functions under the given event name,\r\n                    passing any additional provided arguments to those functions.\r\n\r\n                    @param {string} eventName The name of the event to emit.\r\n                    @param {...any} var_args The arguments to pass to each of the registered events.\r\n                    @returns {void}\r\n                */\r\n                var emit = function(eventName) {\r\n                    var events = _eventList[eventName];\r\n                    if (z.check.exists(events)) {\r\n                        for (var i = 0; i < events.length; i++) {\r\n                            var ev = events[i];\r\n                            if (z.check.exists(ev.func)) {\r\n                                ev.func.apply(null, Array.prototype.slice.call(arguments, 1));\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n\r\n                /**\r\n                    Clears all registered functions for a given event name.\r\n                    passing any additional provided arguments to those functions.\r\n\r\n                    @param {string} eventName The name of the event for which to clear events.\r\n                    @returns {void}\r\n                */\r\n                var clear = function(eventName) {\r\n                    z.check.exists(eventName);\r\n                    _eventList[eventName] = null;\r\n                };\r\n\r\n                /**\r\n                    Registers a function for a provided event name.\r\n                    passing any additional provided arguments to those functions.\r\n\r\n                    @param {string} eventName The name of the event on which to register the function.\r\n                    @param {function} eventFunc The function to register for the event.\r\n                    @returns {function} The function used to deregister the event which was just registered.\r\n                */\r\n                var on = function(eventName, eventFunc) {\r\n                    z.check.exists(eventName);\r\n                    z.check.isFunction(eventFunc);\r\n                    var eventList = (_eventList[eventName] || (_eventList[eventName] = []));\r\n                    var currentEvent = {\r\n                        func: eventFunc\r\n                    };\r\n                    eventList.push(currentEvent);\r\n                    var deregister = function() {\r\n                        _eventList[eventName].removeAll(function(x) { return x === currentEvent; }); // remove only by reference\r\n                    };\r\n                    return deregister;\r\n                };\r\n\r\n                /**\r\n                    Extends an object into a events interface with\r\n                    the pre-determined, privately stored properties,\r\n                    returning it back to the original Events() call.\r\n\r\n                    @param {object} eventsObj The object to extend with Events properties.\r\n                    @returns {object} The extended object.\r\n                */\r\n                return (function(eventsObj) {\r\n                    z.defineProperty(eventsObj, \"emit\", { get: function() { return emit; }, writeable: false });\r\n                    z.defineProperty(eventsObj, \"clear\", { get: function() { return clear; }, writeable: false });\r\n                    z.defineProperty(eventsObj, \"on\", { get: function() { return on; }, writeable: false });\r\n                    return eventsObj;\r\n                })({});\r\n\r\n            }\r\n\r\n            return Events;\r\n\r\n        })();\r\n\r\n        z.classes.Events = Events;\r\n        z.events = new z.classes.Events();\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        var functions = z.functions = z.functions || {}; // note that z.functions is already defined with defaults in base.js\r\n\r\n        /**\r\n            Curries a function, allowing it to accept\r\n            partial argument lists at differing times.\r\n\r\n            @source {function} The function to curry.\r\n            @returns The original curried function.\r\n        */\r\n        functions.curry = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.function ? this : arguments[argsIterator++];\r\n            z.assert.isFunction(source);\r\n            var sourceArgs = Array.prototype.slice.call(arguments);\r\n            var sourceArgsLength = source.length;\r\n\r\n            function curried(args) {\r\n                if (args.length >= sourceArgsLength) {\r\n                    return source.apply(null, args);\r\n                }\r\n                return function() {\r\n                    return curried(args.concat(Array.prototype.slice.call(arguments)));\r\n                };\r\n            }\r\n            return curried(sourceArgs);\r\n        };\r\n        \r\n        /**\r\n            Creates a deep copy of an original function.\r\n            To be used for the function.prototype extension.\r\n            \r\n            @this {function}\r\n            @returns A deep copy of the original function.\r\n        */\r\n        var _deepCopy = function() {\r\n            return z.deepCopy(this);\r\n        };\r\n\r\n        /**\r\n            Defines a property on this function.\r\n            To be used for the function.prototype extension.\r\n            \r\n            @this {function}\r\n            @param {string} name The name of the property.\r\n            @param {any} prop The property to add.\r\n            @returns {void}\r\n         */\r\n        var _defineProperty = function(name, propertyDefinition) {\r\n            return z.defineProperty(this, name, propertyDefinition);\r\n        };\r\n\r\n        /**\r\n            Determines the equality of two functions.\r\n            To be used for the function.prototype extension.\r\n            \r\n            @this {function}\r\n            @param {function} func2 The second function to compare.\r\n            @returns True if both functions contain equal items, false if not.\r\n         */\r\n        var _equals = function(func2) {\r\n            return z.equals(this, func2);\r\n        };\r\n\r\n        /**\r\n            Extends the properties on the provided function arguments into the first function provided.\r\n            To be used for the function.prototype extension.\r\n\r\n            @this {function}\r\n            @param {...function} var_args The tail functions to smash.\r\n            @returns {any} A deep copy of the extended functions.\r\n            @throws {error} An error is thrown if any of the provided arguments are not extendable.\r\n        */\r\n        var _extend = function(/* ...arguments */) {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args.unshift(this);\r\n            return z.functions.extend.apply(null, args);\r\n        };\r\n\r\n        /**\r\n            Extends the properties on the provided function arguments into the first function provided.\r\n            \r\n            @param {...function} var_args The tail functions to use for extension.\r\n            @returns {any} A deep copy of the extended functions.\r\n            @throws {error} An error is thrown if any of the provided arguments are not extendable.\r\n        */\r\n        functions.extend = function(/* ...arguments */) {\r\n            return z.extend.apply(null, arguments);\r\n        };\r\n\r\n        /**\r\n            Returns the argument names for the function as an array.\r\n\r\n            @param {function} source The function for which to collect arguments.\r\n            @returns {array} An array containing any named arguments.\r\n        */\r\n        functions.getArgumentNames = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.function ? this : arguments[argsIterator++];\r\n            z.assert.isFunction(source);\r\n            var s = source.toString();\r\n            var args = s.substring(s.indexOf(\"(\")+1, s.indexOf(\")\")).trim().split(\",\");\r\n            args.map(function(val, index, arr) {\r\n                arr[index] = val.trim().replace(/(\\n)?\\/\\*\\*\\//g, \"\"); // new Function() will append /**/ to argument lists, sometimes with a new line\r\n            });\r\n            return args;\r\n        };\r\n\r\n        /**\r\n            Returns the body of the provided function as a string.\r\n\r\n            @param {function} source The function from which to collect the body.\r\n            @returns {string} A string representation of the function body.\r\n        */\r\n        functions.getBody = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.function ? this : arguments[argsIterator++];\r\n            z.assert.isFunction(source);\r\n            var s = source.toString();\r\n            return s.toString().substring(s.indexOf(\"{\")+1, s.indexOf(\"}\")).trim();\r\n        };\r\n\r\n        /**\r\n            Smashes the properties on the provided function arguments into a single function.\r\n            To be used for the function.prototype extension.\r\n\r\n            @this {function}\r\n            @param {...function|object} var_args The tail functions to smash.\r\n            @returns {any} A deep copy of the smashed functions.\r\n            @throws {error} An error is thrown if any of the provided arguments are not functions.\r\n        */\r\n        var _smash = function(/* ...arguments */) {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args.unshift(this);\r\n            return z.functions.smash.apply(null, args);\r\n        };\r\n\r\n        /**\r\n            Smashes the properties on the provided function arguments into a single function.\r\n            \r\n            @param {...function|object} var_args The tail functions to smash.\r\n            @returns {any} A deep copy of the smashed functions.\r\n            @throws {error} An error is thrown if any of the provided arguments are not functions.\r\n        */\r\n        functions.smash = function(/* ...arguments */) {\r\n            return z.smash.apply(null, arguments);\r\n        };\r\n\r\n        /**\r\n            Initializes all pre-defined methods\r\n            as non-enumerable and non-writable properties\r\n            located on the function.prototype.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initFunctions = function(usePrototype) {\r\n            if (!!usePrototype) {\r\n                z.defineProperty(Function.prototype, \"curry\", { enumerable: false, writable: false, value: functions.curry });\r\n                z.defineProperty(Function.prototype, \"deepCopy\", { enumerable: false, writable: false, value: _deepCopy });\r\n                z.defineProperty(Function.prototype, \"defineProperty\", { enumerable: false, writable: false, value: _defineProperty });\r\n                z.defineProperty(Function.prototype, \"equals\", { enumerable: false, writable: false, value: _equals });\r\n                z.defineProperty(Function.prototype, \"extend\", { enumerable: false, writable: false, value: _extend });\r\n                z.defineProperty(Function.prototype, \"getArgumentNames\", { enumerable: false, writable: false, value: functions.getArgumentNames });\r\n                z.defineProperty(Function.prototype, \"getBody\", { enumerable: false, writable: false, value: functions.getBody });\r\n                z.defineProperty(Function.prototype, \"smash\", { enumerable: false, writable: false, value: _smash });\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n\r\n    function factory(z) {\r\n\r\n        /**\r\n            A method used by the location.parameters property which builds the \r\n            window.location.href query parameters into an object containing key value pairs.\r\n\r\n            @returns {object} The object containing query parameter key value pairs.\r\n        */\r\n        var _regexPlus = /\\+/g; // define once\r\n        var getParameters = function() {\r\n            var params = {};\r\n            if (typeof window !== 'undefined') {\r\n                var href = window.location.href;\r\n                var indexOfQueries = href.indexOf(\"?\");\r\n                if (indexOfQueries > -1) {\r\n                    var queries = href.substring(indexOfQueries+1).split(\"&\");\r\n                    for (var i = 0; i < queries.length; i++) {\r\n                        var query = queries[i].split(\"=\");\r\n                        if (query.length !== 2) continue;\r\n                        params[query[0]] = decodeURIComponent(query[1].replace(_regexPlus, \" \"));\r\n                    }\r\n                }\r\n            }\r\n            return params;\r\n        };\r\n\r\n        /**\r\n            A method used by the location.locale property which collects the locale from\r\n            either the querystring parameters, or the navigator language and userLanguage properties.\r\n\r\n            @returns {string} A string representation of the current locale.\r\n        */\r\n        var getLocale = function() {\r\n            // note: \"this\" should be a pointer to the locationObj defined below\r\n            return this.parameters.locale || navigator.language || navigator.userLanguage;\r\n        };\r\n\r\n        /**\r\n            An interface class used with the window.location object.\r\n            Note that the provided log interface is expected to contain at least\r\n            a debug, error, info, log, and warn method.\r\n\r\n            @class Contains a window.location interface.\r\n        */\r\n        var location = (function(locationObj) {\r\n            z.defineProperty(locationObj, \"parameters\", { get: function() { return getParameters(); }, writeable: false });\r\n            z.defineProperty(locationObj, \"locale\", { get: function() { return getLocale.call(this); }, writeable: false });\r\n            return locationObj;\r\n        })({});\r\n\r\n        z.location = location;\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        var data = {\r\n            expectedMethods: [\r\n                \"log\"\r\n                // \"debug\"\r\n                // , \"error\"\r\n                // , \"info\"\r\n                // , \"log\"\r\n                // , \"warn\"\r\n            ]\r\n        };\r\n\r\n        /**\r\n            An internal helper function used to determine\r\n            whether or not the provided logger object\r\n            is a proper interface for the Log class.\r\n        \r\n            @param {object} logger The log interface to check for expected methods\r\n        */\r\n        var verifyLoggerInterface = function(logger) {\r\n            z.assert.exists(logger);\r\n            for (var i = 0; i < data.expectedMethods.length; i++) {\r\n                var method = data.expectedMethods[i];\r\n                z.assert.isFunction(logger[method]);\r\n            }\r\n        };\r\n\r\n        /**\r\n            Helper method used to binds the LogInterfaces's internal interface\r\n            to the provided external logger interface methods.\r\n\r\n            @param {object} loggerToBind The interface containing the expected log methods.\r\n            @param {object} newLogInterface The object reference to the LogInterface's internal interface.\r\n            @returns {void}\r\n        */\r\n        var bindLoggers = function(loggerToBind, newLogInterface) {\r\n            verifyLoggerInterface(loggerToBind);\r\n            newLogInterface.log = loggerToBind.log.bind(loggerToBind);\r\n\r\n            // fall back to using the \"log\" method \r\n            newLogInterface.debug = z.check.exists(loggerToBind.debug) ? loggerToBind.debug.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n            newLogInterface.error = z.check.exists(loggerToBind.error) ? loggerToBind.error.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n            newLogInterface.info = z.check.exists(loggerToBind.info) ? loggerToBind.info.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n            newLogInterface.warn = z.check.exists(loggerToBind.warn) ? loggerToBind.warn.bind(loggerToBind) : loggerToBind.log.bind(loggerToBind);\r\n        };\r\n\r\n        /**\r\n            A wrapper class used to hold and execute different logging interfaces.\r\n            Note that the provided log interface is expected to contain at least\r\n            a debug, error, info, log, and warn method.\r\n\r\n            @class Contains a provided logging interface.\r\n         */\r\n        var LogInterface = (function() {\r\n\r\n            /**\r\n                Creates a new Log class.\r\n\r\n                @constructor\r\n                @param {object} logger The interface containing the expected log methods.\r\n                @param {bool} [enableDebugLogging] An override for enabling debug logging on Log class creation.\r\n            */\r\n            function LogInterface(logger, enableDebugLogging) {\r\n\r\n                var _internalLogInterface = {};\r\n\r\n                /**\r\n                    Sets the use debug logging flag to the provided boolean.\r\n\r\n                    @param {boolean} useDebugLogging The boolean used to set the debug logging flag.\r\n                    @returns {void}\r\n                */\r\n                var setDebugLogging = function(useDebugLogging) {\r\n                    if (z.getType(useDebugLogging) === z.types.string) {\r\n                        useDebugLogging = (function(str) {\r\n                            switch (str.toLowerCase().trim()) {\r\n                                case \"false\":\r\n                                case \"0\":\r\n                                case \"\":\r\n                                case null:\r\n                                case undefined:\r\n                                    return false;\r\n                                default:\r\n                                    return true;\r\n                            }\r\n                        })(useDebugLogging);\r\n                    }\r\n                    _internalLogInterface.useDebugLogging = !!useDebugLogging;\r\n                };\r\n\r\n                /**\r\n                    Sets the already created log object\r\n                    to the newly provided logger interface.\r\n\r\n                    Note that method is also immediately executed\r\n                    to initialize the provided logger interface.\r\n                    \r\n                    @param {object} newLogger The new logger interface.\r\n                    @returns {void}\r\n                */\r\n                var setLogger = function(newLogger) {\r\n                    bindLoggers(newLogger, _internalLogInterface);\r\n                    setDebugLogging(enableDebugLogging != null ? enableDebugLogging : (z.location ? z.location.parameters.debug : false));\r\n                };\r\n                setLogger(logger);\r\n\r\n                /**\r\n                    Extends a function into a log interface with\r\n                    the pre-determined, privately stored properties,\r\n                    returning it back to the original Log() call.\r\n\r\n                    @returns {function} The extended function.\r\n                */\r\n                return (function(newLog) {\r\n                    /**\r\n                        The base LogInterface function to be returned.\r\n                        Note that the base function can be called\r\n                        as a pass-through method for the _log without\r\n                        needing to directly call LogInterface.log()\r\n\r\n                        Note: Using this method seems a LOT safer,\r\n                        and prevents _log from containing a self-reference.\r\n                        The downside is that the console call will be recorded \r\n                        as coming from this location in log.js,\r\n                        instead of the util.log() line in client code.\r\n\r\n                        @param {any} [x] The item to pass to the LogInterface.log() function.\r\n                        @returns {any} The extended item.\r\n                    */\r\n                    // var newLog = function(x) {\r\n                    //     _log(x); // default a LogInterface(x) call to use _log(x)\r\n                    // };\r\n\r\n                    z.defineProperty(newLog, \"debug\", {\r\n                        get: function() { \r\n                            if (_internalLogInterface.useDebugLogging) {\r\n                                return _internalLogInterface.debug;\r\n                            }\r\n                            else {\r\n                                return z.functions.empty;\r\n                            }\r\n                        },\r\n                        writeable: false\r\n                    });\r\n                    z.defineProperty(newLog, \"error\", { get: function() { return _internalLogInterface.error; }, writeable: false });\r\n                    z.defineProperty(newLog, \"info\", { get: function() { return _internalLogInterface.info; }, writeable: false });\r\n                    z.defineProperty(newLog, \"log\", { get: function() { return _internalLogInterface.log; }, writeable: false });\r\n                    z.defineProperty(newLog, \"warn\", { get: function() { return _internalLogInterface.warn; }, writeable: false });\r\n                    z.defineProperty(newLog, \"setDebugLogging\", { get: function() { return setDebugLogging; }, writeable: false });\r\n                    z.defineProperty(newLog, \"setLogger\", { get: function() { return setLogger; }, writeable: false });\r\n                    return newLog;\r\n                })(_internalLogInterface.log); // note these shenanigans -- seems dangerous, and _log will contain a self-reference\r\n            }\r\n\r\n            return LogInterface;\r\n            \r\n        })();\r\n\r\n        /**\r\n            Initializes a logger interface provided by the setup object.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initLogger = function(defaultLogger) {\r\n            if (z.check.exists(defaultLogger)) {\r\n                z.log = new z.classes.LogInterface(defaultLogger);\r\n            }\r\n        };\r\n\r\n        z.classes.LogInterface = LogInterface;\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        var numbers = z.numbers = {};\r\n\r\n        /**\r\n            Calculates and returns the factors for the provided integer.\r\n            \r\n            @param {integer} source The original integer.\r\n            @returns An array containing the divisors for the integer.\r\n        */\r\n        numbers.factors = function(/* source */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            z.assert.isNumber(source);\r\n            var small = [];\r\n            var large = [];\r\n            for (var i = 1; i <= Math.floor(Math.sqrt(source)); i++) {\r\n                if (source % i === 0) {\r\n                    small.push(i);\r\n                    if (source / i !== i) {\r\n                        large.push(source / i);\r\n                    }\r\n                }\r\n            }\r\n            return small.concat(large.reverse()); // note: push and reverse is anywhere from 2x-54x faster than using unshift\r\n        };\r\n\r\n        /**\r\n            Rounds the provided number to the nearest provided step.\r\n            \r\n            @param {number} source The original number.\r\n            @param {number} roundBy The step to round by.\r\n            @returns {number}\r\n        */\r\n        numbers.round = function(/* source, roundBy, direction */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            var roundBy = arguments[argsIterator++] || 1;\r\n            var direction = arguments[argsIterator++];\r\n            z.assert.isNumber(source);\r\n            if (direction) {\r\n                direction = direction.toString().toLowerCase();\r\n                if (direction === 'down') {\r\n                    return z.numbers.roundDown(source, roundBy);\r\n                }\r\n                else if (direction === 'up') {\r\n                    return z.numbers.roundUp(source, roundBy);\r\n                }\r\n            }\r\n            return Math.round(source / roundBy) * roundBy;\r\n        };\r\n\r\n        /**\r\n            Rounds the provided number down to the nearest provided step.\r\n            \r\n            @param {number} source The original number.\r\n            @param {number} roundBy The step to round by.\r\n            @returns {number} \r\n        */\r\n        numbers.roundDown = function(/* source, roundBy */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            var roundBy = arguments[argsIterator++] || 1;\r\n            z.assert.isNumber(source);\r\n            return Math.floor(source / roundBy) * roundBy;\r\n        };\r\n\r\n        /**\r\n            Rounds the provided number up to the nearest provided step.\r\n            \r\n            @param {number} source The original number.\r\n            @param {number} roundBy The step to round by.\r\n            @returns {number} \r\n        */\r\n        numbers.roundUp = function(/* source, roundBy */) {\r\n            var argsIterator = 0;\r\n            var source = z.getType(this) === z.types.number ? this : arguments[argsIterator++];\r\n            var roundBy = arguments[argsIterator++] || 1;\r\n            z.assert.isNumber(source);\r\n            return Math.ceil(source / roundBy) * roundBy;\r\n        };\r\n\r\n        /**\r\n            Initializes all pre-defined methods\r\n            as non-enumerable and non-writable properties\r\n            located on the Number.prototype.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initNumbers = function(usePrototype) {\r\n            if (!!usePrototype) {\r\n                z.defineProperty(Number.prototype, \"factors\", { enumerable: false, writable: false, value: z.numbers.factors });\r\n                z.defineProperty(Number.prototype, \"round\", { enumerable: false, writable: false, value: z.numbers.round });\r\n                z.defineProperty(Number.prototype, \"roundDown\", { enumerable: false, writable: false, value: z.numbers.roundDown });\r\n                z.defineProperty(Number.prototype, \"roundUp\", { enumerable: false, writable: false, value: z.numbers.roundUp });\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        var objects = z.objects = {};\r\n        \r\n        /**\r\n            Creates a deep copy of an original object.\r\n            To be used for the Object.prototype extension.\r\n            \r\n            @this {object}\r\n            @returns A deep copy of the original object.\r\n         */\r\n        var _deepCopy = function() {\r\n            return z.deepCopy(this);\r\n        };\r\n\r\n        /**\r\n            Defines a property on this object.\r\n            To be used for the Object.prototype extension.\r\n            \r\n            @this {object}\r\n            @param {string} name The name of the property.\r\n            @param {any} prop The property to add.\r\n            @returns {void}\r\n         */\r\n        var _defineProperty = function(name, propertyDefinition) {\r\n            return z.defineProperty(this, name, propertyDefinition);\r\n        };\r\n\r\n        /**\r\n            Determines the equality of two objects.\r\n            To be used for the Object.prototype extension.\r\n            \r\n            @this {object}\r\n            @param {object} obj2 The second object to compare.\r\n            @returns True if both objects contain equal items, false if not.\r\n         */\r\n        var _equals = function(obj2) {\r\n            return z.equals(this, obj2);\r\n        };\r\n\r\n        /**\r\n            Extends the properties on the provided object arguments into the first object provided.\r\n            To be used for the Object.prototype extension.\r\n\r\n            @this {object}\r\n            @param {...object} var_args The tail objects to smash.\r\n            @returns {any} A deep copy of the smashed objects.\r\n            @throws {error} An error is thrown if any of the provided arguments are not objects.\r\n        */\r\n        var _extend = function(/* arguments */) {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args.unshift(this);\r\n            return z.objects.extend.apply(null, args);\r\n        };\r\n\r\n        /**\r\n            Extends the properties on the provided object arguments into the first object provided.\r\n            \r\n            @param {...object} var_args The tail objects to use for extension.\r\n            @returns {any} A deep copy of the smashed objects.\r\n            @throws {error} An error is thrown if any of the provided arguments are not objects.\r\n        */\r\n        objects.extend = function(/* arguments */) {\r\n            return z.extend.apply(null, arguments);\r\n        };\r\n\r\n        /**\r\n            Smashes the properties on the provided object arguments into a single object.\r\n            To be used for the Object.prototype extension.\r\n\r\n            @this {object}\r\n            @param {...object} var_args The tail objects to smash.\r\n            @returns {any} A deep copy of the smashed objects.\r\n            @throws {error} An error is thrown if any of the provided arguments are not objects.\r\n        */\r\n        var _smash = function(/* arguments */) {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args.unshift(this);\r\n            return z.objects.smash.apply(null, args);\r\n        };\r\n\r\n        /**\r\n            Smashes the properties on the provided object arguments into a single object.\r\n            \r\n            @param {...object} var_args The tail objects to smash.\r\n            @returns {any} A deep copy of the smashed objects.\r\n            @throws {error} An error is thrown if any of the provided arguments are not objects.\r\n        */\r\n        objects.smash = function(/* arguments */) {\r\n            return z.smash.apply(null, arguments);\r\n        };\r\n\r\n        /**\r\n            Initializes all pre-defined methods\r\n            as non-enumerable but writable properties\r\n            located on the Object.prototype.\r\n            \r\n            @returns {void}\r\n        */\r\n        z.setup.initObjects = function(usePrototype) {\r\n            if (!!usePrototype) {\r\n                z.defineProperty(Object.prototype, \"deepCopy\", { enumerable: false, writable: true, value: _deepCopy });\r\n                z.defineProperty(Object.prototype, \"defineProperty\", { enumerable: false, writable: true, value: _defineProperty });\r\n                z.defineProperty(Object.prototype, \"equals\", { enumerable: false, writable: true, value: _equals });\r\n                z.defineProperty(Object.prototype, \"extend\", { enumerable: false, writable: true, value: _extend });\r\n                z.defineProperty(Object.prototype, \"smash\", { enumerable: false, writable: true, value: _smash });\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}());","/*\r\n    @license\r\n    Copyright (C) 2014 Dave Lesage\r\n    License: MIT\r\n    See license.txt for full license text.\r\n*/\r\n;(function(undefined) {\r\n    \"use strict\";\r\n    function factory(z) {\r\n\r\n        z.classes = z.classes || {};\r\n\r\n        /**\r\n            A class wrapper to contain a stack of stopwatches.\r\n            \r\n            @class Represents a stack of currently executing tasks.\r\n        */\r\n        var StopwatchStack = (function() {\r\n\r\n            /**\r\n                @constructor Initializes a new instance of the StopwatchStack class.\r\n            */\r\n            function StopwatchStack() {\r\n\r\n                var _stopwatchStack = [];\r\n\r\n                /**\r\n                    Creates and pushes a new StopwatchWrapper onto the task\r\n                    which contains the given taskDescription.\r\n                \r\n                    @param {string} taskDescription The description for the task to be timed.\r\n                    @returns {void}\r\n                */ \r\n                var _push = function(taskDescription) {\r\n                    _stopwatchStack.push(new StopwatchWrapper(taskDescription));\r\n                };\r\n\r\n                /**\r\n                    Pops the topmost executing StopwatchWrapper from the stack,\r\n                    which in turn will log the execution time using util.log.\r\n                 \r\n                    @param {string} taskDescription The description for the task to be timed.\r\n                    @returns {void}\r\n                */\r\n                var _pop = function() {\r\n                    if (_stopwatchStack.length > 0) {\r\n                        _stopwatchStack.pop().stop();\r\n                    }\r\n                };\r\n\r\n                return (function(swObj) {\r\n                    z.defineProperty(swObj, \"push\", { get: function() { return _push; }, writeable: false });\r\n                    z.defineProperty(swObj, \"pop\", { get: function() { return _pop; }, writeable: false });\r\n                    return swObj;\r\n                })({});\r\n            }\r\n\r\n            return StopwatchStack;\r\n\r\n        })();\r\n\r\n        /**\r\n            Creates a new StopwatchWrapper, designed to wrap\r\n            the existing StopWatch class with a task description\r\n            and a logging functionality.\r\n\r\n            Used to keep the Stopwatch class clean,\r\n            so it may be implemented without\r\n            automated logging if necessary.\r\n\r\n            @class Represents a currently executing task.\r\n        */\r\n        function StopwatchWrapper(taskDescription) {\r\n            var sw = new Stopwatch();\r\n            var taskDesc = taskDescription || \"\";\r\n            this.stop = function() {\r\n                sw.stop();\r\n                z.log.debug(taskDesc + \" took: \" + sw.duration() + \" ms\");\r\n            };\r\n            sw.start();\r\n        }\r\n\r\n        /**\r\n            Creates a new Stopwatch.\r\n            \r\n            @class Represents a timer.\r\n        */\r\n        function Stopwatch() {\r\n            var _startTime = null;\r\n            var _stopTime = null;\r\n            var _running = false;\r\n\r\n            /**\r\n                Starts the stopwatch.\r\n                \r\n                @returns {void}\r\n            */\r\n            this.start = function() {\r\n                if (!_running) {\r\n                    _stopTime = null;\r\n                    _running = true;\r\n                    _startTime = new Date().getTime();\r\n                }\r\n            };\r\n\r\n            /**\r\n                Stops the stopwatch.\r\n                \r\n                @returns {void}\r\n            */\r\n            this.stop = function() {\r\n                if(_running) {\r\n                    _stopTime = new Date().getTime();\r\n                    _running = false;\r\n                }\r\n            };\r\n\r\n            /**\r\n                Collects the execution duration for the stopwatch.\r\n                \r\n                @returns {number} The duration of the timer in milliseconds.\r\n            */\r\n            this.duration = function() {\r\n                if (!_running) {\r\n                    return (_stopTime - _startTime);\r\n                }\r\n                else {\r\n                    return (new Date().getTime() - _startTime);\r\n                }\r\n            };\r\n\r\n            /**\r\n                Resets the stopwatch to the initialized state. the execution duration for the stopwatch.\r\n                \r\n                @returns {void}\r\n            */\r\n            this.reset = function() {\r\n                _running = false;\r\n                _startTime = null;\r\n                _stopTime = null;\r\n            };\r\n        }\r\n\r\n        z.classes.StopwatchStack = StopwatchStack;\r\n        z.classes.StopwatchWrapper = StopwatchWrapper;\r\n        z.classes.Stopwatch = Stopwatch;\r\n        z.sw = new z.classes.StopwatchStack();\r\n    }\r\n\r\n    /**\r\n        Locate root, and determine how to use the factory method.\r\n    */\r\n    var root = (\r\n        typeof window !== 'undefined' ?\r\n            window\r\n            :  typeof global !== 'undefined' ?\r\n                global \r\n                : this\r\n    );\r\n    if (typeof define !== 'undefined' && typeof define.amd !== 'undefined') {\r\n        // define.amd exists\r\n        define(function() { return factory; });\r\n        root.z = z; // expose to root in case require() is not being used to load zana\r\n    }\r\n    else if (typeof module !== 'undefined') {\r\n        if (typeof module.exports !== 'undefined') {\r\n            module.exports = factory;\r\n        }\r\n    }\r\n    else if (typeof root.z !== 'undefined') {\r\n        // pass root.z to the factory\r\n        factory(root.z);\r\n    }\r\n}()); "],"sourceRoot":"/source/"}