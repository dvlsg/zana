<!DOCTYPE html>
<html>
<head lang="en">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Zana ES6 Example</title>

    <script type="text/javascript;version=1.7" src="../../src/es6-dev/base.js"></script>

    <script type="text/javascript;version=1.7" src="../../src/es6-dev/arrays.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/assert.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/check.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/convert.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/events.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/generators.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/iterables.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/location.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/log.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/match.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/objects.js"></script>
    <script type="text/javascript;version=1.7" src="../../src/es6-dev/stopwatch.js"></script>
</head>
    <body>
        <h1>Running example with es6 zana...</h1>
        <h2>Please check the console for results</h2>
    </body>
    <script type="text/javascript;version=1.7">
        (function() {
            z.setup({
                useArrayExtensions: true,
                useFunctionExtensions: true,
                // useGeneratorExtensions: true, // to show that we can use the new Iterable class without generator extensions
                useNumberExtensions: true,
                useObjectExtensions: true,
                defaultLogger: console
            });
            var log = z.log;
            log.setDebugLogging(true);
            var from = z.from;
            var sw = z.sw;
            var it, it2, arr, arr2, arr3, set1, gen;

            gen = function*() {
                var count = 0;
                while (++count < 10)
                    yield count;
            };


            // test out some joins
            arr = [
                  { id: 1, data: 'Data1', quantity: 2 }
                , { id: 2, data: 'Data2', quantity: 3 }
                , { id: 3, data: 'Data3', quantity: 1 }
                , { id: 4, data: 'Data4', quantity: 5 }
                , { id: 5, data: 'Data5', quantity: 3 }
            ];
            arr2 = [
                  { id: 1, type: 'square' }
                , { id: 3, type: 'ellipse' }
                , { id: 3, type: 'circle' }
                , { id: 5, type: 'square' }
                , { id: 7, type: 'triangle' }
                , { id: 9, type: 'triangle' }
            ];
            arr3 = [
                  { id: 10, type: 'square',   price: 5.25 }
                , { id: 11, type: 'ellipse',  price: 12.23 }
                , { id: 12, type: 'circle',   price: 9.40 }
                , { id: 12, type: 'triangle', price: 3.87 }
            ];
            set3 = new Set([ // to prove we can use more than just arrays. note that WeakSets are not iterable.
                  { id: 10, type: 'square',   price: 5.25 }
                , { id: 11, type: 'ellipse',  price: 12.23 }
                , { id: 12, type: 'circle',   price: 9.40 }
                , { id: 12, type: 'triangle', price: 3.87 }
            ]);

            // it = from(arr);
            // log([...it]);
// 
            // return;

            // it = from(arr)
            //     .innerJoin(arr2)
            //     .on((x,y) => x.id === y.id)
            //     .innerJoin(arr3)
            //     .on((x,y,z) => y.type === z.type)
            //     .where((x,y,z) => x.quantity < 3 && y.type != 'square')
            //     .select((x,y,z) => ({
            //         id: x.id,
            //         data: x.data,
            //         type: y.type,
            //         quantity: x.quantity,
            //         price: z.price
            //     }))
            //     .toArray();
            // log(it);

            // it = from(arr)
            //     .leftJoin(arr2)
            //     .on((x, y) => x.id === y.id)
            //     .select((x,y) =>  ({
            //         id: x.id,
            //         data: x.data,
            //         type: y.type
            //     }))
            //     .toArray();
            // log(it);

            // it = from(arr)
            //     .crossJoin(arr2)
            //     .select((x,y) => ({
            //         id: x.id,
            //         data: x.data,
            //         type: y.type
            //     }))
            //     .toArray();
            // log(it);

            // it = from(arr)
            //     .leftJoin(arr2)
            //     .on((x,y) => x.id === y.id)
            //     .leftJoin(set3)
            //     .on((x,y,z) => y.type === z.type)
            //     .select((x,y,z) => ({
            //         id: x.id,
            //         data: x.data,
            //         type: y.type, // just to show that we will get y.type === undefined when the left join has no match.
            //         price: z.price 
            //     }))
            //     .toArray();
            // log(it);


            // // test out flatten
            // it = from([[[[[[[1,[2]],[3,[4],[5]]]]]]]])
            //     .flatten()
            //     .toArray();
            // log(it);

            // // this is the official way to create a map using the constructor as of 2015-01-31
            // // not sure why we can't pass an object instead...
            // var m = new Map([
            //     ["a", 1]
            //     , ["b", 2]
            //     , ["c", 3]
            // ]);
            // log(m);
            // for (var [key, val] of m) // this works great. doesn't work with objects (if only).
            //     log(key, val);
            // for (var v of m)
            //     log(v); // this returns [key, val]. awkward to work with.
            // it = from(m.values()) // suggest using m.values() at the user level if using iterable.
            //     .toArray(); // returns an array of arrays containing [key, val]. also awkward.
            // log(it);

            // // for (var [key, val] of o) // this doesnt work at all.
            //     // log(key, val);

            // var s = new Set([1, 1, 1, 2, 3, 4, 5, 2, 4]); // duplicates should be removed
            // var s2obj = { d: 4 };
            // var s2 = new Set([
            //       { a: 1 }
            //     , { b: 2 }
            //     , { c: 3 } // both of these will be added,
            //     , { c: 3 } // since they aren't equal by reference.
            //     , s2obj // only one of these will be added,
            //     , s2obj // since they are equal by reference.
            //     // not entirely sure how this differs from weakset,
            //     // other than weakset only allows non-primitive types,
            //     // and doesn't prevent garbage collection.
            // ]);
            // log(s2);

            // var g = function*() {
            //     yield ["a", 1]; // map most likely yields items like this.
            //     yield ["b", 2]; // is this a problem for our join/flatten solution(?)
            //     yield ["c", 3]; // or do we say screw it, if you're using iterables, don't use keys?
            //     // not sure if any other enumerable implementations actually have keys/indices.
            // };

            // log("Symbol.toStringTag:", Symbol.toStringTag);
            // log("type of iterable:", z.getType(from([1,2,3])));
            // log('type of set:', z.getType(s));
            // log('type of generator:', z.getType(g));
            // log('type of generator expanded:', z.getType(g()));
            // log('type of map:', z.getType(m));

            // for (let [key, val] of g())
            //     log(key, val);

            // for (var val of g())
            //     log(val);

            // z.forEach(g, function(val, key, iter) {
            //     log('iterable foreach', val, key); 
            // });

            // log(s);
            // it = from(s) // this works fine, sets are iterable.
            //     .toArray();
            // log(it);
            // z.forEach(s, function(val, key, set) {
            //     log(val, key, set);
            // });

            // log(from(s).contains(6));
            // log(from(s).at(4));
            // log(from(s).isEmpty());
            // log(from(s).isFull());

            // // mixing array and generator comprehensions with iterables
            // var stuff = [for (x of from((for (x of [1,2,3,1,4,5]) if (x > 1) x*x)).orderBy(x=>x)) x];
            // log('stuff:', stuff);


            // // .on((x,y) => x.id === y.id)

            // // array extension version of innerJoin

            //     // x.id === y.id)
            //     // .innerJoin(arr3)
            //     // .on((x,y,z) => y.type === z.type)
            //     // .where((x,y,z) => x.quantity < 3 && y.type != 'square')

            // var extend = z.extend;

            // // .select((x,y,z) => ({
            // //         id: x.id,
            // //         data: x.data,
            // //         type: y.type,
            // //         quantity: x.quantity,
            // //         price: z.price
            // //     }))

            // sw.push('array comprehensions');
            // for (var i = 0; i < 1000; i++) {
            //     stuff = [
            //         for (x of arr)
            //         for (y of arr2)
            //         if (x.id === y.id && x.quantity < 3)
            //         for (z of arr3)
            //         if (y.type === z.type && y.type != 'square')
            //         {
            //             id: x.id,
            //             data: x.data,
            //             type: y.type,
            //             quantity: x.quantity,
            //             price: z.price
            //         }
            //     ];
            //     // stuff is already an array in this case
            // }
            // sw.pop(); // 1000 iterations -> ~9-15ms
            // log(stuff);

            // sw.push('generator comprehensions');
            // for (var i = 0; i < 1000; i++) {
            //     stuff = (
            //         for (x of arr)
            //         for (y of arr2)
            //         if (x.id === y.id && x.quantity < 3)
            //         for (z of arr3)
            //         if (y.type === z.type && y.type != 'square')
            //         {
            //             id: x.id,
            //             data: x.data,
            //             type: y.type,
            //             quantity: x.quantity,
            //             price: z.price
            //         }
            //     );
            //     stuff = [...stuff];
            // }
            // sw.pop(); // 1000 iterations -> ~15-20ms
            // log(stuff);

            // sw.push('generator comprehensions with predicates');
            // var on1 = (x,y) => x.id === y.id;
            // var on2 = (x,y,z) => y.type === z.type;
            // var where1 = (x,y,z) => x.quantity < 3 && y.type != 'square';
            // for (var i = 0; i < 1000; i++) {
            //     stuff = (
            //         for (x of arr)
            //         for (y of arr2)
            //         if (on1(x,y))
            //         for (z of arr3)
            //         if (on2(x,y,z))
            //         if (where1(x,y,z))
            //         {
            //             id: x.id,
            //             data: x.data,
            //             type: y.type,
            //             quantity: x.quantity,
            //             price: z.price
            //         }
            //     );
            //     stuff = [...stuff];
            // }
            // sw.pop(); // 1000 iterations -> ~15-20ms
            // log(stuff);

            // sw.push('iterable joins');
            // for (var i = 0; i < 1000; i++) {
            //     stuff = from(arr)
            //         .leftJoin(arr2)
            //         .on((x,y) => x.id === y.id)
            //         .leftJoin(arr3)
            //         .on((x,y,z) => y.type === z.type)
            //         .where((x,y,z) => x.quantity < 3 && y.type != 'square')
            //         .select((x,y,z) => ({
            //             id: x.id,
            //             data: x.data,
            //             type: y.type,
            //             quantity: x.quantity,
            //             price: z.price
            //         }));
            //     stuff = [...stuff];
            // }
            // sw.pop(); // 1000 iterations -> ~440ms (ouch... pretty much signifies the death of iterable where, select, and joins.)
            // log(stuff);

            var crossed = [
                for (x of arr)
                for (y of arr2)
                for (z of arr3)
                {
                    id: x.id,
                    data: x.data,
                    type: y.type,
                    quantity: x.quantity,
                    price: z.price
                }
            ];

            log("crossed");
            log(arr.length);
            log(arr2.length);
            log(arr3.length);
            log(crossed);

            sw.push("array filter");
            for (var i = 0; i < 1000; i++) {
                stuff = crossed.filter(x => x.quantity > 3);
                stuff = [...stuff];
                // already an array
            }
            sw.pop();
            log(stuff);

            var it = from(crossed);
            log(it.toArray());

            log(it.data);

            sw.push("iterables where");
            for (var i = 0; i < 1000; i++) {
                stuff = from(crossed).where(x => x.quantity > 3); //.where(x => x.quantity > 3);
                stuff = [...stuff];
            }
            sw.pop();
            log(stuff);

            sw.push("iterables non-extension where");
            for (var i = 0; i < 1000; i++) {
                stuff = z.iterables.where(crossed, x => x.quantity > 3);
                stuff = [...stuff()];
            }
            sw.pop();
            log(stuff);

            sw.push("where without the where");
            for (var i = 0; i < 1000; i++) {
                var pred = x => x.quantity > 3;
                var gen = function*() {
                    for (var v of crossed) {
                        if (pred(v))
                            yield v;
                    }
                }
                stuff = [...from(gen)];
            }
            sw.pop();
            log(stuff);

            // function* yielder() {
            //     yield [1,2];
            //     yield [3,4];
            //     yield [5,6];
            // }

            // for (var v of yielder()) {
            //     log(v);
            // }

            // function prod(...args) {
            //     var index = 0;
            //     var end = args.length-1;

            //     return function*() {
            //         var result = [];
            //         for (var v of (args[index]))

            //     }
            // }

            // function* _prod(arrs, index) {
            //     if (index >= arrs.length) {
            //         yield* _prod(arrs, index+1); 
            //     }
            // }

            // function _prod(arrs, index) {
            //     // return function*() {
            //     //     if (index < arrs.length) {
            //     //         for (var v of arrs[index]) {
            //     //             log('v', v);
            //     //             yield [v, ..._prod(arrs, index+1)()];
            //     //         }
            //     //     }
            //         // if (index === arrs.length-1) {
            //         //     for (var v of arrs[index])
            //         //         yield v;
            //         // }
            //         // else {
            //         //     for (var v of arrs[index]) {
            //         //         yield [v, ..._prod(arrs, index+1)()];
            //         //     }
            //         // }
            //     }
            // }
            // function prod(...arrs) {
            //     // return _prod(arrs, 0);

            //     return function*() {
            //         for (var v of _prod(arrs, 0)) {

            //         }
            //     }
            //     // return function*() {
            //     //     if (arrs && arrs.length > 0) {
            //     //         for (var v of arrs[0]) {
            //     //             log('v', v);
            //     //             for (var v2 of prod(...arrs.slice(1))()) {
            //     //                 log('v2', v2);
            //     //                 yield [v, ...v2];
            //     //             }
            //     //         }
            //     //     }
            //     // }
            // }

            // var s = [
            //     for (x of arr)
            //     for (y of arr)
            //     if (x.id === y.id)
            //     {
            //         id: x.id
            //         , data: y.data
            //         , quantity: y.quantity
            //     }
            // ];
            // log(s);


            // Array.prototype.poly = function(fun/*, thisArg*/) {
            //     'use strict';

            //     if (this === void 0 || this === null) {
            //       throw new TypeError();
            //     }

            //     var t = Object(this);
            //     var len = t.length >>> 0;
            //     if (typeof fun !== 'function') {
            //       throw new TypeError();
            //     }

            //     var res = [];
            //     var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
            //     for (var i = 0; i < len; i++) {
            //       if (i in t) {
            //         var val = t[i];

            //         // NOTE: Technically this should Object.defineProperty at
            //         //       the next index, as push can be affected by
            //         //       properties on Object.prototype and Array.prototype.
            //         //       But that method's new, and collisions should be
            //         //       rare, so use the more-compatible alternative.
            //         if (fun.call(thisArg, val, i, t)) {
            //           res.push(val);
            //         }
            //       }
            //     }
            //     return res;
            // };

            

            // sw.push("array polyfilter"); // about 5x faster than built in filter? what?
            // for (var i = 0; i < 1000; i++) {
            //     stuff = crossed.poly(x => x.quantity > 3);
            //     // already an array
            // }
            // sw.pop();
            // log(stuff);

            // var _reverse = function*(iter, a) {
            //     if (!a.done) {
            //         yield* _reverse(iter, iter.next());
            //         yield a.value;
            //     }
            // };
            // iterables.reverse = function(iter) {
            //     return function*() {
            //         var expandedIter = _expand(iter);
            //         yield* _reverse(expandedIter, expandedIter.next());
            //     };
            // };

            // THIS WORKS. SAVE.
            function* _prod(arrs, current, index) {
                if (index == arrs.length-1) {
                    for (var v of arrs[index]) {
                        current[index] = v;
                        yield([...current]); // needs to be a copy, since current gets re-used
                    }
                }
                else {
                    for (var v of arrs[index]) {
                        current[index] = v;
                        yield* _prod(arrs, current, index+1);
                    }
                }
            }
            function prod(...arrs) {
                return function*() {
                    yield* _prod(arrs, [], 0);
                }
                // return _prod(arrs, [], 0); // also works -- returns already expanded.
            }


            // function prod2(...arrs) {
            //     var stuff = function*(){};
            //     for (var v of arrs) {

            //     }
            // }

            sw.push("cartesian generator"); // about 5x faster than built in filter? what?
            for (var i = 0; i < 1000; i++) {
                var stuff = prod([0,1,2],[3],[4,5,6,7]);
                log(stuff);
                log(from(stuff).toArray());
                stuff = [...from(stuff)];
            }
            sw.pop();
            for (var v of stuff)
                log(v);

            // sw.push("cartesian comprehension"); // about 5x faster than built in filter? what?
            // for (var i = 0; i < 1000; i++) {
            //     stuff = (
            //         for (x of [0,1,2])
            //         for (y of [3])
            //         for (z of [4,5,6,7])
            //         [x,y,z]
            //     );
            //     stuff = [...stuff];
            // }
            // sw.pop();

        }());
    </script>
</html>